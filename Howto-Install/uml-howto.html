<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>User-Mode Linux Root File System</title>
<body>
<h2>Creating UML Root File System and MLN template</h2> 
 
    <a href="http://140.120.7.20/uml-rfs/README.html#MLNTemplate"  
    target="newwindow">Create Our own DebianNet Template for MLN</a> 
<h2>Finally, got it worked</h2> 
 
  <p> The following procedures will create an UML mimicking your host.  It is not  
     suitable for UML Servers, (such as: UML Dns, http, IP, mail, servers, etc,)  
     deployment.  (They need much less system resource.)  It is only good for High  
     Availability Cluster Management! 
 
<h3>On the host side</h3> 
<OL> 
  <LI><a href="#PUML" target="newwindow">Preparation for UML</a> 
 
  <LI><a href="#DebSqz" target="newwindow">UMLrf For Debian/Squeeze</a>&nbsp;&nbsp;
      <a href="#CRFUML" target="newwindow">Creating Root File System for UML</a> 

<P> The second anchor is a reference for creating UML Root Filesystem for Ubuntu, 
   a rather bad choice.  This is a mistake I made before. I keep it here for 
   historical reason.  Nowadays, We base our UML (user mode linux) virtualization 
   on Debian, a much wiser choice!
 
  <LI>X window support on the host side: 
 
   <P>If user mode linux is going to provide X window capability, make sure host can  
      provide it from remote login. Login the host from a remote host via ssh command.  
      After seeing the login prompt, login and run the xterm command in it: 
<PRE> 
$ xterm& 
</PRE> 
 
      <p> If xterm window shows up, type "exit" in the new xterm window.  You are sure  
          your uml will be able to provide X window services. 
 
      <p><b>Note:</b> First line  
         <code>"127.0.0.1 localhost.localdomain localhost"</code> in  
         <code>/etc/hosts</code> should not be deleted. 
 
 
       <p>Also, the suffix string "-nolisten tcp" in file  
       <code>/etc/X11/xinit/xserverrc</code> prevents all remote machines from  
       getting X window support.  It seems that the uml will not be able to share  
       X window from host because of it! 
 
<PRE> 
$ diff  /etc/X11/xinit/xserverrc /etc/X11/xinit/xserverrc.orig 
2c2 
< exec /usr/bin/X11/X -dpi 100 
--- 
> exec /usr/bin/X11/X -dpi 100 -nolisten tcp 
</PRE> 
 
  <LI>Bring up uml by: 
 
<PRE> 
$ startUML 
$ cat startUML 
#! /bin/bash 
# Do NOT edit this file, it is automatically generated by ./Config-UML-Rfs! 
 
############################################################# 
IsThereTapDevice() 
  { 
   declare int i=0; 
   for devices in `find /sys/class/net -type l -name "tap*"` 
     do 
       ((i++)); 
     done 
 
   if [ ${i} -gt 0 ] 
     then echo "Yes" 
   else echo "No" 
   fi 
  } 
############################################################# 
 
sudo echo Need SU passwd:  
sudo chmod 666 /dev/net/tun 
sudo tunctl -u hsu -t tap0 
sudo ifconfig tap0 192.168.0.32 netmask 255.255.255.255 up 
 
if [ `IsThereTapDevice` = "No" ] 
   then sudo iptables --flush 
        sudo iptables --table nat --flush 
        sudo iptables --delete-chain 
        sudo iptables --table nat --delete-chain 
        sudo iptables --table nat --append POSTROUTING --out-interface eth2 -j MASQUERADE 
fi  
 
sudo iptables --append FORWARD --in-interface tap0 -j ACCEPT 
sudo chmod 666 /dev/net/tun # The first time, we get 660 on /dev/net/tun 
sudo sysctl net.ipv4.ip_forward=1 
sudo sysctl net.ipv4.conf.tap0.proxy_arp=1 
sudo arp -Ds 192.168.0.233 eth2 pub 
sudo route add -host 192.168.0.233 dev tap0 
vde_switch -tap tap0 -mod 644 -sock=/src3/UML/network-5081 -mgmt /src3/UML/network-5081/vde_switch.mgmt -daemon </dev/null >/dev/null 
linux.uml ubd0=DebWzy.ext4 eth0=vde,/src3/UML/network-5081 mem=256M con=pty con0=fd:0,fd:1 umid=mv01 
</PRE> 
 
<P><b>Note:</b> This startUML script is prepared by Config-UML-Rfs. No more sudoer 
  script.  Replacing "echo 1 &gt; /proc/sys...." by <b>sysctl</b> command. The  
  sudoer script is also prepared by Config-UML-Rfs, since "sudo echo" is not allowed  
  to be executed for security reason, sii!! 
 
  <LI> [Optional!] The tun kernel loadable module is a char device with major and  
     minor numbers 10 and 200, respectively.  
<PRE> 
$ ls -l /etc/modprobe.d/alia* 
-rw-r--r-- 1 root root 4652 2008-03-13 16:11 /etc/modprobe.d/aliases 
-rw-r--r-- 1 root root 4624 2007-10-06 01:10 /etc/modprobe.d/aliases.orig 
# Add the following line to invoke tun kernel modules: 
$ diff  /etc/modprobe.d/aliases /etc/modprobe.d/aliases.orig 
81d80 
< alias char-major-10-200 tun 
</PRE> 
</OL> 
 
<h3>On the UML side</h3> 
<OL> 
  <LI> The first time UML is up:  <b>You must disable ssh root login!</b> 
 
<P> With su privilege, change the line "PermitRootLogin yes" to "PermitRootLogin no" 
    in the <code>/etc/ssh/sshd_config</code> (ssh daemon configuration) file. 
    Then execute <code>/etc/init.d/ssh restart</code> to let the change to take  
    effect. 
 
  <LI> These steps are taken care by commands in <code>/etc/rc.local</code> file  
       already.  But the information provided is still relevant. 
 
<P> When kernel almost finishes booting, before the system is online, this  
   <code>/etc/rc.local</code> script is invoked.   
 
  <LI> Debian UML does not have such problem: 
 
  <P> Each time we run linux.uml, the ether number in  
      <code>/etc/udev/rules.d/70-persistent-net.rules</code> file get incremented by 1. 
 
      <P> Prepare a <code>/etc/udev/rules.d/70-persistent-net.rules.sample</code> file. 
Before shut down the uml, copy it to  
      <code>/etc/udev/rules.d/70-persistent-net.rules</code> 
 
<PRE> 
guest@av-03:~$ cat  /etc/udev/rules.d/70-persistent-net.rules.sample 
 
# This file maintains persistent names for network interfaces. 
# See udev(7) for syntax. 
# 
# Entries are automatically added by the 75-persistent-net-generator.rules 
# file; however you are also free to add your own entries. 
 
</PRE> 
 
<PRE> 
guest@av-03:~$ su 
Password: 
root@av-03:/home/guest# cp /etc/udev/rules.d/70*net*sample /etc/udev/rules.d/70-persistent-net.rules 
root@av-03:/home/guest# halt            
</PRE> 
 
 
  <LI> Exporting Host File Systems, such as: <code>/usr/local</code> and  
     <code>/src2</code> to UML 
 
    <P>Can be done automatically through commands in <code>/etc/rc.local</code> file. 
  <LI> Shut the UML down: 
 
<PRE> 
 # In uml terminal,  
 $ su 
 # halt -f 
 # In the original host, at the directory starting the last UML, 
 $ restore-lan 
</PRE> 
</OL> 
 
<h3>Relevant Info</h3> 
 
<OL> 
  <LI> Need to bring up eth0 manually.  Don't know why. 
 
<p><b>Note: Problem Solved!</b> After multiuser mode is ready, before going online,  
    system boot procedure will call "/etc/rc.local", the local run command script. 
    We turn on ethernet and add route to host in this script.   
<p><b>Note: (2010/12/09)</b> Still does not work for Ubuntu!  Either "/etc/rc.local" 
    was not invoked during system startup or event was not properly handled. 
    Must login, get xterm and run "sudo /etc/rc.local" manually on it. 
 
<PRE> 
guest@av-03:~$ ifconfig 
lo        Link encap:Local Loopback 
          inet addr:127.0.0.1  Mask:255.0.0.0 
          UP LOOPBACK RUNNING  MTU:16436  Metric:1 
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b) 
 
guest@av-03:~$ ifconfig -a 
eth0      Link encap:Ethernet  HWaddr 16:22:4C:FF:30:EF 
          BROADCAST MULTICAST  MTU:1500  Metric:1 
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b) 
          Interrupt:5 
 
lo        Link encap:Local Loopback 
          inet addr:127.0.0.1  Mask:255.0.0.0 
          UP LOOPBACK RUNNING  MTU:16436  Metric:1 
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b) 
 
guest@av-03:~$ su 
root@av-03:/home/guest# ifconfig eth0 192.168.0.231 
# If uml is to be allowed to reach out, let host be its gw. 
root@av-03:/home/guest# route add default gw 192.168.0.31 
</pre> 
 
  <LI>Always use -a option to run ifconfig, since it could get exported to uml, but we 
      can not see it! (Because of no permission?) 
<PRE> 
$ ifconfig -a  
</PRE> 
</OL> 
<h3>Duplicate UMLs</h3> 
 
<P> We can duplicate more UMLs after the first one is running smoothly: 
<OL> 
  <LI> Shut down the running UML. 
 
  <LI> Copy its root file system to a new one. 
 
  <LI> Run <b>Config-UML-Rfs</b> with 4 or 5 arguments: 
 
<PRE> 
$ Config-UML-Rfs root-fs-pathname hostname UML-IP Eth-Card [TAP-No] 
#    Argument 5 is optional, if need tap to be different from tap0. 
$ Config-UML-Rfs /src3/UML/uml-rfs-new test1 192.168.0.232 eth2 1 
# $ ln Config-UML-Rfs Config-UML-Rfs-UmlSwitch 
# When script is invoked by Config-UML-Rfs-UmlSwitch, it writes script using uml_switch. 
# Otherwise, it writes script using vde_switch, with syntax more close to kvm script. 
# Do we get any benefit?  I honestly don't know! 
</PRE> 
 
  <P>  Frequently, we have several ether cards in our host machine, especially if our  
  built-in Eather Cards were not supported by Linux.  We can get the HostIp from our 
  main ether card, i.e. the one we get connected to the Internet.  The <b>Eth-Card</b> 
  parameter must be this one which connects us to the Internet. 
</OL> 
 
<h3>Unresolved Questions (Resolved!!)</h3> 
 
<OL> 
  <LI> With super user id, update software packages as follow: 
 
<PRE> 
 # apt-get update 
 # apt-get upgrade 
</PRE> 
 
  <LI> Software Packages Update: 
 
      <P> Can we use synaptic to update software packages? Doing it remotely is not  
     possible, X11 connection rejected.  This is understandable and we offer almost  
     no protection on virtual machines, if synaptic can be used to update software  
     packages, it should be done on UML console.  And after populating file system,  
     we have upgraded it once via: <code>apt-get dselect-upgrade</code> 
  <LI> Should host <code>/usr/lib</code> be mounted on UML? 
 
      <P> No, I believe!  Since the software packages may use shared object files  
     in the <code>/usr/lib</code> directory.  If we have not upgraded our software  
     in time, if some command, such as firefox, still use old libraries, we will  
     be in trouble!  Recently, firefox has been upgraded in host.  In UML, we are  
     not able to invoke it anymore. 
 
      <P> Shut av-05 down, and bring it up again without the <code>/usr/lib</code>  
     directory mounted, can firefox be invoked again?  This is a nice test case!! 
 
      <P> Case in point, host ac04 and ac05 have <code>/usr/bin/gcin</code> which  
     is needed by firefoxes in the host machines.  But in UML-root-fs, firefox  
     package installation does not install it.  When running firefox in UML av-04,  
     av-05, we are running it according to <code>/usr/lib/firefox</code> in the  
     <b>host</b> machines, not the UML <code>/usr/lib/firefox</code> anymore. 
     When mounting uml-root-fs on /mnt/tmp, these two directories are quite  
     different! 
</OL> 
 
 
<h2><a name="PUML">Preparation for UML</a></h2> 
<OL> 
  <LI><a href="http://140.120.7.20/LinuxRef/UML/UmlCompilation.html" 
        target="newwindow">Compiling Our own UML Kernel</a> and  
      <code>$ sudo apt-get install uml-utilities fuse-utils</code> 
 
      <P> We need <code>/dev/net/tun</code> device file which is provided by  
       <b>uml-utilities</b> package. 
  <LI>Installing debootstrap for creating minimal root file system the uml will  
      boot upon: 
 
<pre> 
 $ sudo apt-get install debootstrap 
</pre> 
 
  <LI> Nowadays, we use vde (virtual distributed ethernet) packages in virtual  
      machines, we hence also install <b>libvde0</b>, <b>vde2</b> packages so  
      that <b>vde_switch</b> will be available.  Note: <b>vde_switch</b> can  
      be used in both the UML and KVM environments, it unifies our shell script  
      syntax and ethernet interface. I hope this will be the right choice. 
 
      <P> If you compile your own linux.uml kernel as the way described in the  
          first item, you are done.  The <b>uml-utilities</b> and <b>fuse-utils</b>  
          packages are OK, now.  The next two items are for historical reason. <hr> 
  <LI>Installing user-mode-linux, user-mode-linux-doc via synaptic. 

   <P> This installs the uml kernel.  For better software quality, we later on 
      switched to Debian user-mode-linux.  The newest package:  
      <a href="http://packages.debian.org/squeeze/user-mode-linux" 
      target="newwindow">Debian Squeeze user-mode-linux</a>. 

  <LI>Uml-utilities: 

 <P> <b>/dev/net/tun</b>, tunnel, device is provided by <b>uml_utilities</b> 
   See <a href="http://user-mode-linux.sourceforge.net/minis.html"  
      target="newwindow">uml_utilities source from this site</a>, also. 

<PRE>
 $ sudo apt-get install uml_utilities
</PRE>

   <P>By default, <b>tunctl</b> command from uml-utilites is installed in  
      <code>/usr/sbin</code>.  The one compiled by us gets installed in  
      <code>/usr/bin</code>.  Override the default one by: 
 
<pre> 
 $ sudo cp /usr/bin/tunctl /usr/sbin/tunctl 
</pre> <hr> 
</OL> 
 
<h2><a name="CRFUML">Creating Root File System for UML</a></h2> 
<OL> 
  <LI>We need 4GB disk space, including 2GB for UML /usr. 
<PRE> 
 $ dd if=/dev/zero of=./uml-root-fs bs=1024K count=4000 
 $ mkfs.ext4 uml-root-fs 
 $ sudo mkdir /mnt/tmp # a directory to mount uml-root-fs on. 
 $ sudo mount -o loop uml-root-fs /mnt/tmp 
 # You just create an empty logic block device in uml-root-fs. 
 # You can mount it.  It's empty, except lost+found directory. 
 $ ls -l /mnt/tmp 
total 16 
drwx------ 2 root root 16384 2008-02-28 11:13 lost+found 
</pre> 
 
  <LI>Install bare minimal root file system 
 
   <P> With your uml-root-fs still mounted on <code>/mnt/tmp</code>,  
   <b>(be patient!)</b> 
 
<pre> 
 $ sudo debootstrap --arch amd64 gutsy /mnt/tmp http://archive.ubuntulinux.org/ubuntu 
 # If your system is P686 down to i386, (not including Dual Core Intel CPU) 
 # sudo debootstrap --arch i386 gutsy /mnt/tmp http://archive.ubuntulinux.org/ubuntu 
 $ ls -l /mnt/tmp 
total 88 
drwxr-xr-x  2 root root  4096 2008-02-28 11:28 bin 
drwxr-xr-x  2 root root  4096 2007-10-08 18:47 boot 
drwxr-xr-x  4 root root  4096 2008-02-28 11:28 dev 
drwxr-xr-x 46 root root  4096 2008-02-28 11:28 etc 
drwxr-xr-x  2 root root  4096 2007-10-08 18:47 home 
drwxr-xr-x  2 root root  4096 2008-02-28 11:26 initrd 
drwxr-xr-x 13 root root  4096 2008-02-28 11:27 lib 
drwx------  2 root root 16384 2008-02-28 11:13 lost+found 
drwxr-xr-x  2 root root  4096 2008-02-28 11:26 media 
drwxr-xr-x  2 root root  4096 2007-10-08 18:47 mnt 
drwxr-xr-x  2 root root  4096 2008-02-28 11:26 opt 
drwxr-xr-x  2 root root  4096 2007-10-08 18:47 proc 
drwxr-xr-x  2 root root  4096 2008-02-28 11:26 root 
drwxr-xr-x  2 root root  4096 2008-02-28 11:28 sbin 
drwxr-xr-x  2 root root  4096 2008-02-28 11:26 srv 
drwxr-xr-x  2 root root  4096 2007-10-04 19:17 sys 
drwxrwxrwt  2 root root  4096 2008-02-28 11:27 tmp 
drwxr-xr-x 10 root root  4096 2008-02-28 11:26 usr 
drwxr-xr-x 13 root root  4096 2008-02-28 11:26 var 
 $ ls -l /mnt/tmp/usr/local/bin 
total 0 
</pre> 
<LI>At this point your system is an unconfigured base system. You will need to  
    edit the following files (in <code>/mnt/tmp/etc</code>) in order to have your  
    system in a valid configured state. 
 
<P> 
<TABLE> 
  <TR><TD>apt/sources.list&nbsp;&nbsp; 
      <TD>fstab&nbsp;&nbsp; 
      <TD>hostname&nbsp;&nbsp; 
      <TD>hosts&nbsp;&nbsp; 
  <TR><TD>network/interfaces&nbsp;&nbsp; 
      <TD>rc.local&nbsp;&nbsp; 
      <TD>securetty&nbsp;&nbsp; 
      <TD>udev/rules.d/70-persistent-net.rules 
</TABLE> 
 
 
<P><b>Note:</b> On step 5, Config-UML-Rfs shell script helps you configure your root  
   file system automatically. 
 
<LI> With uml-root-fs still mounted on <code>/mnt/tmp</code>, 
 
<P> You may explore it as follow. <b>Don't forget to umount it at the last stage.</b> 
 
<PRE> 
 $ ls -l /mnt/tmp/etc/apt/sources.list /mnt/tmp/etc/fstab /mnt/tmp/etc/hostname \ 
         /mnt/tmp/etc/hosts /mnt/tmp/etc/network/interfaces  /mnt/tmp/etc/rc.local \ 
         /mnt/tmp/etc/securetty 
ls: /mnt/tmp/etc/hosts: No such file or directory 
-rw-r--r-- 1 root root  53 2008-03-22 10:38 /mnt/tmp/etc/apt/sources.list 
-rw-r--r-- 1 root root  37 2008-03-22 10:36 /mnt/tmp/etc/fstab 
-rw-r--r-- 1 root root   6 2007-10-12 11:34 /mnt/tmp/etc/hostname 
-rw-r--r-- 1 root root 123 2008-03-22 10:37 /mnt/tmp/etc/network/interfaces 
-rwxr-xr-x 1 root root 306 2008-03-22 10:37 /mnt/tmp/etc/rc.local 
-rw-r--r-- 1 root root 994 2007-05-18 17:59 /mnt/tmp/etc/securetty 
 $ more  /mnt/tmp/etc/fstab 
# UNCONFIGURED FSTAB FOR BASE SYSTEM 
 $ more /mnt/tmp/etc/apt/sources.list 
deb http://archive.ubuntulinux.org/ubuntu gutsy main 
 $ more /mnt/tmp/etc/hostname 
tiger 
 $ more  /mnt/tmp/etc/network/interfaces 
# Used by ifup(8) and ifdown(8). See the interfaces(5) manpage or 
# /usr/share/doc/ifupdown/examples for more information. 
 $ more  /mnt/tmp/etc/securetty 
# /etc/securetty: list of terminals on which root is allowed to login. 
# See securetty(5) and login(1). 
console 
   . 
   . 
   . 
</PRE> 
 
<P> <b>Umount the UML Root File System:</b> 
<PRE> 
$ sync 
$ sudo umount /mnt/tmp 
</PRE> 
 
<LI> Get Tools and Necessary files from /backup/UML-tool 
 
<p> Suppose you are in the directory for creating UML Root File system. 
 
<PRE> 
 $ if [ ! -d FILES ] 
     then mkdir FILES 
   fi 
 $ cp /backup/UML-tool/Config-UML-Rfs /backup/UML-tool/dpkg.selections.txt . 
 $ cp /backup/UML-tool/FILES/* FILES 
</PRE> 
 
<P> You may replace <b>cp</b> by <b>scp</b> command to get the above files  
from <b>as</b> server. 
 
<LI> Configure the UML Root File system by: 
 
<PRE> 
 $ Config-UML-Rfs /src3/UML/uml-root-fs av-03 192.168.0.231 eth2  
</PRE> 
  
<P> In the above command line,  
 
<OL> 
  <LI> The first argument <code>/src3/UML/uml-root-fs</code> 
   needs to be replaced by the absolute pathname of your Uml Root Filesystem.   
  <LI> The  
   second argument <code>av-03</code> needs to be replaced by the actual name of your 
   UML.   
  <LI> The third argument <code>192.168.0.231</code> needs to be replaced by the  
   actual (unique) IP-address of UML.   
  <LI> The fourth argument <code>192.168.0.31</code>  
   needs to be replaced by the IP address of the machine which is going to host your  
   UML.  
  <LI> The fifth argument <code>192.168.0.1</code> needs to be replaced by the  
   Gateway IP-address of your network.  
</OL> 
 
<P><b>Note:</b> Now, <b>Config-UML-Rfs</b> accepts 5th optional argument, a  
   number for the tap of the tun/tap (software simulation) device.  UML tunnels  
   its net packets to its host and host uses tap0, tap1, tap3 as network bridges. 
   [ google: tuntap device ] 
 
<P> If you wish, mount <code>uml-root-fs</code> to <code>/mnt/tmp</code> to verify  
   the last 8 files listed in Step 3 are in place and have correct contents in them.  
   Don't forget to umount it after finishing exploring it. 
</OL> 
 
<h2>Populating Root File System with apt-get:</h2> 
 
<b>Reference:</b> <a href="http://http://www.knoppix.net/wiki/Debootstrap_to_LiveCD"  
    target="newwindow">Debootstrap to LiveCD</a> 
 
<OL>  
  <LI> Find what we have installed in host and delete the ones we don't need: 
<PRE> 
$ dpkg --get-selections | tee  /tmp/dpkg.selections.txt 
$ emacs /tmp/dpkg.selections.txt 
# linux-image-2.6.22-14-generic, linux-image-generic, mplayer, mplayer-skins,  
# Everything about openoffice, linux-source* 
# ppp, pppconfig, pppoeconf, tomboy, totem, totem-gstreamer, totem-mozilla 
# ttf-lao, ttf-malayalam-fonts, ttf-thai-tlwg 
</PRE> 
   
  <p><b>Note</b>: It is too late!  We need to get the output of the command of  
       <code>dpkg --get-selections</code> right after we installed Linux 
       and test that it functions normally after reboot.   
 
  <p><b>On second thought</b>: Maybe not.  We still need some software development 
     environment, tools, and various libraries which are installed much later. 
 
  <LI> <a href="./dpkg.selections.txt" target="newwindow">dpkg.selections.txt</a> 
 
       <P><b>Note:</b> This example file contains 416 packages. Is there any  
        package dependency can not be resolved? 
       <P><b>Yes:</b> openssh-server configuration is incomplete.  But it seems no  
         harm is done. UML is still functioning. 
       <P><b>Brute Force Attacks</b>:  This is a rather serious problem, since UML  
         deployment.  We must install and configure <b>fail2ban</b> package to  
         prevent it from happening. 
 
  <LI> And chroot to /mnt/tmp directory, install packages to uml-root-fs.  
 
       <P><b>Note:</b> Must umount /proc so that we will be able to umount  
         <code>/mnt/tmp</code>, later on. 
 
<PRE> 
$ sudo mount -o loop uml-root-fs /mnt/tmp 
$ cp dpkg.selections.txt  /mnt/tmp/tmp 
$ sudo chroot /mnt/tmp 
# adduser guest 
# apt-get update 
# apt-get -f install 
# for pkg in `grep "\binstall$" /tmp/dpkg.selections.txt | awk '{print $1} '`; \ 
 do apt-get -y --force-yes install $pkg; done 
# apt-get dselect-upgrade 
# umount /proc 
# exit 
 
if [ ! -f /mnt/tmp/etc/ssh/ssh_config.orig ] 
  then sudo mv /mnt/tmp/etc/ssh/ssh_config /mnt/tmp/etc/ssh/ssh_config.orig 
fi 
 
sudo cp /etc/ssh/ssh_config /mnt/tmp/etc/ssh/ssh_config 
ls -l /mnt/tmp/var/cache/apt/archives/*deb 
du /mnt/tmp/var/cache/apt/archives 
sudo rm  /mnt/tmp/var/cache/apt/archives/*deb 
sudo cp $HOME/.profile FILES/myterm /mnt/tmp/home/guest 
sudo umount /mnt/tmp # (bound to fail, unless /proc is umounted?) 
</PRE> 
 
Shutdown and restart the system. Hopefully, your uml-root-fs is ready!! 
 
</OL> 
 
<h3>Preventing Brute Force Attack on sshd</h3> 
 
  <P> After deployment of UML, Brute Force Attacks on ssh are coming continuously, 
mostly from Mainland China.  We need to install and configure <code>fail2ban</code> 
package.  Ubuntu <code>fail2ban 0.8.2-2</code> package has a bug in it.  Must load  
it from Debian <code>fail2ban 0.8.2-3</code>. 
 
    <h2>Preventing Brute Force Attacks With Fail2ban On Debian Etch  
<a href="http://www.howtoforge.com/fail2ban_debian_etch"  
target="newwindow">(Source Origin)</a></h2> 
                                                             
 
<div class="KonaBody"><!-- begin content --><div class="node"> 
 
    
  <div class="info">Submitted by <a href="http://www.howtoforge.com/forums/member.php?u=2" title="View user profile." rel="nofollow">falko</a> (<a href="http://www.howtoforge.com/forums/private.php?do=newpm&amp;u=2" title="Contact author." rel="nofollow">Contact Author</a>) (<a href="http://www.howtoforge.com/forums" title="Forums.">Forums</a>) on Tue, 2007-05-01 18:05.<span class="taxonomy"> :: <a href="http://www.howtoforge.com/sitemap/linux/debian">Debian</a> | <a href="http://www.howtoforge.com/sitemap/security">Security</a></span></div> 
  <div class="content"> 
  <h2>Preventing Brute Force Attacks With Fail2ban On Debian Etch </h2> 
<p>Version 1.0<br> 
  Author: Falko Timme &lt;ft [at] falkotimme [dot] com&gt; <br> 
Last edited 04/24/2007</p> 
<p>In this article I will show how to install and configure <a mce_real_href="http://www.fail2ban.org" href="http://www.fail2ban.org/" target="_blank">fail2ban</a> 
on a Debian Etch system. Fail2ban is a tool that observes login 
attempts to various services, e.g. SSH, FTP, SMTP, Apache, etc., and if 
it finds failed login attempts again and again from the same IP address 
or host, fail2ban stops further login attempts from that IP 
address/host by blocking it with an iptables firewall rule.</p> 
 
<h3>Preliminary Note</h3> 
<p> Fail2ban is similar to <a mce_real_href="http://denyhosts.sourceforge.net/"  
href="http://denyhosts.sourceforge.net/" target="_blank">DenyHosts</a> which I  
covered in this tutorial:  
<a href="http://www.howtoforge.com/preventing_ssh_dictionary_attacks_with_denyhosts"  
target="newwindow">Preventing Ssh Dictionary Attacks With Denyhosts</a>, 
but unlike DenyHosts which focuses on SSH, fail2ban can be configured 
to monitor any service that writes login attempts to a log file, and 
instead of using <code>/etc/hosts.deny</code> to block IP  
addresses/hosts, fail2ban uses iptables.</p> 
<p>In this example I will configure fail2ban to monitor login attempts 
to the SSH server, the Proftpd server, login attempts to 
.htaccess/.htpasswd protected web sites, to Courier POP3 and Courier 
IMAP, and to SASL (for sending emails). I will install the fail2ban 
package that is available for Debian Etch. It comes with a default 
configuration, but unfortunately that configuration doesn't quite work 
for most of the aforementioned services. Therefore I will create a 
customized fail2ban configuration that I have tested and that works for 
me. </p> 
 
<h3>Installing fail2ban</h3> 
<p>Fail2ban can be installed as follows on Debian Etch:</p> 
<p class="command">apt-get install fail2ban</p> 
<p>Afterwards, you will find all fail2ban configuration files in the  
<code>/etc/fail2ban</code> directory.  </p> 
 
<h3>Configuring fail2ban</h3> 
<p>The default behaviour of fail2ban is configured in the file  
<code>/etc/fail2ban/jail.conf</code>. Take a look at it, it's not hard to  
understand. There's a <span class="system">[DEFAULT]</span> section that  
applies to all other sections unless the default options are overriden in  
the other sections. </p> 
<p>I explain some of the configuration options here:</p> 
<ul> 
  <li><span class="system">ignoreip</span>: This is a 
space-separated list of IP addresses that cannot be blocked by 
fail2ban. For example, if the computer from which you're connecting to 
the server has a static IP address, you might want to list it here.</li> 
  <li><span class="system">bantime</span>: Time in seconds that a host is  
blocked if it was caught by fail2ban (600 seconds = 10 minutes).</li> 
  <li><span class="system">maxretry</span>: Max. number of failed login  
attempts before a host is blocked by fail2ban.</li> 
  <li><span class="system">filter</span>: Refers to the appropriate filter  
file in <span class="system">/etc/fail2ban/filter.d</code>.</li> 
  <li><span class="system">logpath</span>: The log file that fail2ban checks  
for failed login attempts.</li> 
</ul> 
<p>As suggested by a comment at the top of <code>/etc/fail2ban/jail.conf</code>,  
we don't modify <code>/etc/fail2ban/jail.conf</code> itself to adjust it to our  
needs, but override it by creating a new configuration file,  
<code>/etc/fail2ban/jail.local</code>.</p> 
<p>This is what my <code>/etc/fail2ban/jail.local</code> file looks like:</p> 
<p class="command">vi /etc/fail2ban/jail.local</p> 
<table class="" align="center" bgcolor="#cccccc" border="1" bordercolor="#000000"  
cellpadding="2" cellspacing="0" width="90%"> 
      <tbody><tr> 
        <td class=""> 
      <pre>[DEFAULT] 
 
# "ignoreip" can be an IP address, a CIDR mask or a DNS host 
ignoreip = 127.0.0.1 192.168.0.99 
bantime  = 600 
maxretry = 3 
 
# "backend" specifies the backend used to get files modification. Available 
# options are "gamin", "polling" and "auto". 
# yoh: For some reason Debian shipped python-gamin didn't work as expected 
#      This issue left ToDo, so polling is default backend for now 
backend = polling 
 
# 
# Destination email address used solely for the interpolations in 
# jail.{conf,local} configuration files. 
destemail = root@localhost 
 
# Default action to take: ban only 
action = iptables[name=%(__name__)s, port=%(port)s] 
 
 
[ssh] 
 
enabled = true 
port    = ssh 
filter  = sshd 
logpath  = /var/log/auth.log 
maxretry = 5 
 
 
[apache] 
 
enabled = true 
port    = http 
filter  = apache-auth 
logpath = /var/log/apache*/*error.log 
maxretry = 5 
 
 
[apache-noscript] 
 
enabled = false 
port    = http 
filter  = apache-noscript 
logpath = /var/log/apache*/*error.log 
maxretry = 5 
 
 
[vsftpd] 
 
enabled  = false 
port     = ftp 
filter   = vsftpd 
logpath  = /var/log/auth.log 
maxretry = 5 
 
 
[proftpd] 
 
enabled  = true 
port     = ftp 
filter   = proftpd 
logpath  = /var/log/auth.log 
failregex = proftpd: \(pam_unix\) authentication failure; .* rhost=&lt;HOST&gt; 
maxretry = 5 
 
 
[wuftpd] 
 
enabled  = false 
port     = ftp 
filter   = wuftpd 
logpath  = /var/log/auth.log 
maxretry = 5 
 
 
[postfix] 
 
enabled  = false 
port     = smtp 
filter   = postfix 
logpath  = /var/log/mail.log 
maxretry = 5 
 
 
[courierpop3] 
 
enabled  = true 
port     = pop3 
filter   = courierlogin 
failregex = courierpop3login: LOGIN FAILED.*ip=\[.*:&lt;HOST&gt;\] 
logpath  = /var/log/mail.log 
maxretry = 5 
 
 
[courierimap] 
 
enabled  = true 
port     = imap2 
filter   = courierlogin 
failregex = imapd: LOGIN FAILED.*ip=\[.*:&lt;HOST&gt;\] 
logpath  = /var/log/mail.log 
maxretry = 5 
 
 
[sasl] 
 
enabled  = true 
port     = smtp 
filter   = sasl 
failregex = warning: [-._\w]+\[&lt;HOST&gt;\]: SASL (?:LOGIN|PLAIN|(?:CRAM|DIGEST)-MD5) authentication failed 
logpath  = /var/log/mail.log 
maxretry = 5</pre> 
</td></tr> 
</tbody></table> 
<p>My client computer has the static IP address <code>192.168.0.99</code>, and  
because I don't want to be locked out, I've added it to the  
<span class="system">ignoreip</span> list. I've set the max. number of failed  
login attempts to 5 for all services, and I've created two new sections,  
<span class="system"> [courierpop3]</span> and  
<span class="system">[courierimap]</span>, so that fail2ban can block login  
attempts to my Courier-POP3 and Courier-IMAP server. </p> 
<p>I want to control login attempts to ssh, apache, proftpd, courierpop3,  
courierimap, and sasl, so I've set <span class="system">enabled</span> to  
<span class="system">true</span> for these services and to  
<span class="system">false</span> for all other services. </p> 
<p>If you compare the file with <code>/etc/fail2ban/jail.conf</code>,  
you'll also notice that I've changed some log files because the log files in  
<code>/etc/fail2ban/jail.conf</code> are not correct for Debian Etch. In addition  
to that, I've added a <span class="system">failregex</span> line to some services  
because the regular expressions in the appropriate filter files in the  
<code>/etc/fail2ban/filter.d</code> directory do not work for Debian Etch.  
The <span class="system">failregex</span> line overrides the filter rule in the  
appropriate file in <code>/etc/fail2ban/filter.d</code>.</p> 
<p>Whenever we modify the fail2ban configuration, we must restart fail2ban, so  
this is what we do now:</p> 
<p class="command">/etc/init.d/fail2ban restart</p> 
<p>That's it already. Fail2ban logs to <code>/var/log/fail2ban.log</code>, so you  
can check that file to find out if/what hosts got blocked. If a host got blocked  
by fail2ban, it looks like this:</p> 
<p class="system">2007-04-24 17:49:09,466 fail2ban.actions: WARNING [apache]  
Ban 1.2.3.4<br> 
  2007-04-24 18:08:33,213 fail2ban.actions: WARNING [sasl] Ban 1.2.3.4<br> 
  2007-04-24 18:26:37,769 fail2ban.actions: WARNING [courierlogin] Ban 1.2.3.4<br> 
2007-04-24 18:39:06,765 fail2ban.actions: WARNING [courierimap] Ban 1.2.3.4 </p> 
<p>You can also check your firewall to see if any hosts are currently blocked. Simply  
run</p> 
<p class="command">iptables -L  </p> 
 
<h3>Links</h3> 
<ul> 
  <li>Fail2ban: <a href="http://www.fail2ban.org/"  
target="newwindow">http://www.fail2ban.org</a></li> 
  <li>Debian: <a href="http://www.debian.org/"  
target="newwindow">http://www.debian.org</a></li> 
</ul><br><div class="copyright-footer">Copyright: 2007 Falko Timme<br>All Rights Reserved. 
</div>  </div> 
 
<h2 class="title"><a name="id2450739"></a>Installing User Mode Linux:  
<a href="http://cosi.clarkson.edu/docs/kernel/setup/uml/uml.html">Source  
Origin</a></h2></div><div><div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="surname">McCabe - COSI </span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Demetrios</span> <span class="surname">Dimatos - COSI</span></h3></div></div><div><div class="revhistory"><table summary="Revision history" border="1" width="100%"><tbody><tr><th colspan="2" align="left" valign="top"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.5</td><td align="left">22 Jan 2006</td></tr><tr><td colspan="2" align="left">Initial draft</td></tr></tbody></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This article will show you how to do a basic  
		installation of usermode linux on a 2.6.15.1 kernel.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#feedback">Feedback</a></span></dt><dt><span class="sect1"><a href="#copyright">Copyright</a></span></dt><dt><span class="sect1"><a href="#disclaimer">Disclaimer</a></span></dt><dt><span class="sect1"><a href="#preqrequisites">Prerequisites</a></span></dt><dt><span class="sect1"><a href="#dlconfigbuild">Download, configure and build</a></span></dt><dd><dl><dt><span class="sect2"><a href="#download">Download</a></span></dt><dt><span class="sect2"><a href="#configure">Configure</a></span></dt><dt><span class="sect2"><a href="#build">Build</a></span></dt></dl></dd><dt><span class="sect1"><a href="#createfs">Creating your filesystem</a></span></dt><dt><span class="sect1"><a href="#resources">Other Resources</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="feedback"></a>Feedback</h2></div></div></div><p> 
Comments on this tutorial may be directed to Michael McCabe <code class="email">&lt;<a href="mailto:mccabemt@clarkson.edu">mccabemt@clarkson.edu</a>&gt;</code></p><p>Comments on this tutorial may be directed to Demetrios Dimatos <code class="email">&lt;<a href="mailto:dimatosd@clarkson.edu">dimatosd@clarkson.edu</a>&gt;</code></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="copyright"></a>Copyright</h2></div></div></div><p> 
This document, <span class="emphasis"><em>Installing User Mode Linux</em></span> is copyright (c) 2006 by the <span class="emphasis"><em>Clarkson Open Source Institute</em></span>.   Permission is granted to copy, 
distribute and/or modify this document under the terms of the GNU Free Documentation License, 
Version 1.1 or any later version published by the Free Software Foundation; with no Invariant  
Sections, with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license is  
available at <a href="http://www.gnu.org/copyleft/fdl.html" target="_top">http://www.gnu.org/copyleft/fdl.html</a>. 
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="disclaimer"></a>Disclaimer</h2></div></div></div><p> 
No liability for the contents of this document can be accepted. 
  Use the concepts, examples and information at your own risk. 
There may be errors and inaccuracies, that could be damaging to your 
 system.  Proceed with caution, and although this is highly unlikely, 
 the author(s) do not take any responsibility. 
</p><p> 
All copyrights are held by their by their respective owners, 
 unless specifically noted otherwise.  Use of a term in this document 
 should not be regarded as affecting the validity of any trademark 
or service mark.  Naming of particular products or brands should 
not be seen as endorsements. 
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="preqrequisites"></a>Prerequisites</h2></div></div></div><p> 
There are several tools and utilities that you will need to have 
installed in order to successfully build and run user-mode linux.   
Some of these tools are optional though, such as the ones that are  
required to have networking for your guests and some other ones are 
 required for you to proceed.  Here is a list of the tools that you  
must have installed.</p><div class="itemizedlist"><ul type="disc"><li><p>GCC-This tutorial was completed with gcc4. The mileage that you may get with other versions of gcc may vary.</p></li><li><p>libstdc++ - in some distributions libstdc++ is GCC, but with Ubuntu it was needed to perform, 
				<span><strong class="command">sudo apt-get install libstdc++6-dev</strong></span> to obtain the needed stdc libs. 
				</p></li><li><p>tar and bzip-Required for extracting the kernel source.</p></li><li><p>make-Used for the kernel build system.</p></li><li><p>ncurses-Ncurses and the development file is used to run the  
	kernel configuration program <span><strong class="command">menuconfig</strong></span>. To install on Ubuntu, <span><strong class="command">sudo apt-get install libncurses5-dev</strong></span></p></li></ul></div><p>Here is a listing of some of the optional tools that you may need.</p><div class="itemizedlist"><ul type="disc"><li><p>telnet-Can be used to connect to guests over there serial lines</p></li><li><p>uml-utilities-Is used to setup serial ports and setup networking on  
	the various parts of the system. 
		</p></li><li><p>debootstrap-Used to create debian or other debian based filesystem  
	images.</p></li><li><p>yum-Can be used to create images of rpm based linux  
		distributions.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="dlconfigbuild"></a>Download, configure and build</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="download"></a>Download</h3></div></div></div><p> 
Before we begin we will need to download the kernel source tree.  There are  
several mirrors that have the kernel source code available for download.  For  
this tutorial we are going with the <span class="emphasis"><em>2.6.15.1</em></span> version of  
the Linux kernel. 
</p><div class="example"><a name="id2450102"></a><p class="title"><b>Example 1. Downloading the Kernel</b></p><pre class="screen">		<code class="prompt">#</code>wget http://mirror.clarkson.edu/pub/linux/kernel/v2.6/linux-2.6.15.1.tar.bz2 
		Alternatevely <a href="http://www.kernel.org/pub/linux/kernel/" target="_top">www.kernel.org</a> 
	</pre></div><p> 
If you download a version of the kernel that is earlier than 2.6.9 you will  
also need to download a seperate patch for the uml architecture. 
</p><p> 
At this point we can now extract the kernel source code.  In this example we  
will be extracting it in the current user's home directory.   
</p><div class="example"><a name="id2450143"></a><p class="title"><b>Example 2. Unpacking the package</b></p><pre class="screen">		<code class="prompt">#</code>cd ~/ 
		<code class="prompt">#</code>tar -xvjf linux-2.6.15.1.tar.bz2 
	</pre></div><p> 
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configure"></a>Configure</h3></div></div></div><p> 
We are now ready to configure our kernel for building it.  There are many  
different kernel options that you will need to select in order to build a  
fully functional kernel.  We will also turn on kernel debugging support and  
debug symbols.  The following command will launch the kernel configuration  
program <span class="emphasis"><em>menuconfig</em></span> 
</p><div class="example"><a name="id2450196"></a><p class="title"><b>Example 3. Kernel Configuration</b></p><pre class="screen">	<code class="prompt">#</code>cd linux-2.6.15.1 
	<code class="prompt">#</code>make ARCH=um menuconfig 
	</pre></div><p> 
</p><p> 
Here is a listing of options that you may need to disable or change in order  
to build a fully functioning kernel 
.</p><div class="itemizedlist"><ul type="disc"><li><pre class="screen">Loadable module support 
	-&gt;Enable loadable module support 	- Not Required 
	  Note:We can't debug these so having this option enabled would be a waste 
	  	</pre></li><li><pre class="screen">UML Specific Options 
	-&gt; Host Processor type features  
		-&gt; Generic x86 support - Disable this 
		-&gt; Processor family (386)  
			-&gt; Choose your proccessor , I chose PIII that coresponded to my laptop. 
		</pre></li><li><pre class="screen">Networking 
	-&gt; Amateur Radio                     - Not Required 
	-&gt; IRDA (infrared) Subsystem Support - Not Required 
	-&gt; Blue tooth Subsytem Support       - Not Required 
		</pre></li><li><pre class="screen">Character devices  
	-&gt; stderr console 	 - Enable  
	-&gt; virtual serial line 	 - Enable 
	-&gt; port channel support  - Enable 
	-&gt; pty channel support 	 - Enable  
	-&gt; tty channel support 	 - Enable 
	-&gt; xterm channel support - Enable 
		</pre></li><li><pre class="screen">Block Devices 
	-&gt; Virtual block devices - Enable 
		</pre></li><li><pre class="screen">UML Network Devices 
	- You may or may not want to turn on the different network options under  
	  these settings. Consult the uml <a href="http://user-mode-linux.sourceforge.net/" target="_top">website</a>for more information on these devices. 
		</pre></li><li><pre class="screen">File systems 
	- To make my kernel build faster I only enabled the couple of filesystems 
	  that I knew that I would need (ext3 was one of them) 
	</pre></li><li><pre class="screen">SCSI support 
	-&gt; SCSI support	- Disable 
	</pre></li><li><pre class="screen">Multi-device support (RAID and LVM) 
	-&gt; Multiple devices driver support (RAID and LVM) - Disable 
</pre></li><li><pre class="screen">Memory Technology Devices (MID) 
	-&gt; Memory Technology Device (MID) support - Disable 
</pre></li><li><pre class="screen">Kernel Hacking  
	-&gt; Show timing information on printks - Enable 
	-&gt; Kernel debugging 		      - Enable 
	-&gt; Compile the Kernel with Debug Info - Enable 
</pre><p> 
		</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="build"></a>Build</h3></div></div></div><p>At this point we can now begin building the linux kernel.   
	</p><div class="example"><a name="id2454657"></a><p class="title"><b>Example 4. Building the kernel</b></p><pre class="screen">	<code class="prompt">#</code>make ARCH=um linux	 
</pre></div><p> 
	When this step is completed you will have a fully functioning user  
	mode linux kernel.  This step will take a while, depending on the  
	speed of your machine. 
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="createfs"></a>Creating your filesystem</h2></div></div></div><p> 
	Debian is suprisingly simple to install inside of user mode linux.  
	To begin you must initialize the files using <span><strong class="command">dd</strong></span>.   
	This example assumes that your image files are  
	<span class="emphasis"><em>/opt/uml/debian-root</em></span>. 
	</p><div class="example"><a name="id2454711"></a><p class="title"><b>Example 5. Creating your filesystem</b></p><pre class="screen">	<code class="prompt">#</code>dd if=/dev/zero of=/opt/uml/debian-root bs=1024K count=1000 
</pre></div><p> 
Now we will initialize the filesystems inside of each of these files. 
We will be using ext3 as our root filesystem.</p><div class="example"><a name="id2454738"></a><p class="title"><b>Example 6. Initializing the filesystems</b></p><pre class="screen">	<code class="prompt">#</code>mkfs.ext4 /opt/uml/debian-root 
</pre></div><p>Now we will need to mount the root filesystem before we run  
<span><strong class="command">debootstrap</strong></span>. 
</p><div class="example"><a name="id2454769"></a><p class="title"><b>Example 7. Mounting root</b></p><pre class="screen">	<code class="prompt">#</code>mkdir /mnt/debian 
	<code class="prompt">#</code>mount -o loop /opt/uml/debian-root /mnt/debian 
</pre></div><p>Now we will install <span><strong class="command">debootstrap</strong></span> and 
 bootstrap a base Debian installation.  This is a barebones  
installation that is less than 200 megs.</p><div class="example"><a name="id2454806"></a><p class="title"><b>Example 8. Debian Installation</b></p><pre class="screen">	<code class="prompt">#</code>apt-get install debootstrap 
	<code class="prompt">#</code>debootstrap --arch i386 sarge /mnt/debian http://ftp.us.debian.org/debian 
				 
	or you may want to use the breezy installation. 
				 
	<code class="prompt">#</code>debootstrap --arch i386 breezy /mnt/debian http://archive.ubuntulinux.org/ubuntu 
</pre></div><p>At this point your system is an unconfigured base system.   
You will need to edit the following files in order to have  
your system in a valid configuration.</p><div class="itemizedlist"><ul type="disc"><li><p>/etc/fstab</p></li><li><p>/etc/hostname</p></li><li><p>/etc/hosts</p></li><li><p>/etc/network/interfaces</p></li><li><p>/etc/apt/sources.list</p></li><li><p>/etc/securetty</p></li><li><p>/etc/inittab</p></li></ul></div><p></p><div class="example"><a name="id2450433"></a><p class="title"><b>Example 9. FSTAB configuration</b></p><pre class="screen">	/dev/ubd0	/	ext3	defaults	0 1 
	proc		/proc	proc	defaults	0 0 
</pre></div><div class="example"><a name="id2450448"></a><p class="title"><b>Example 10. Host configuration</b></p><p>You will need to make sure that <span class="emphasis"><em>/etc/hostname</em></span> contains  
the following line or your nameing preference.</p><pre class="screen">	uml-one  
</pre><p>You will need to make sure that <span class="emphasis"><em>/etc/hosts</em></span> contains  
the following line.</p><pre>	127.0.0.1 localhost.localdomain localhost 
</pre><p>At this point you will need to setup your network interface  
configuration.  This is done by editing the file  
<span class="emphasis"><em>/etc/network/interfaces</em></span>.  This guest will have a  
loopback network device.  More information on configuring network devices under  
Debian can be found in the  
<a href="http://www.debian.org/doc/manuals/reference/reference.en.html" target="_top"> 
Debian Reference</a>.</p></div><div class="example"><a name="id2450506"></a><p class="title"><b>Example 11. The loopback network interface</b></p><pre class="screen">	auto lo 
	iface lo inet loopback 
</pre></div><p>The above should be in the file /etc/network/interfaces. You'll also need to add a mirror or cdrom image to  
<span class="emphasis"><em>/etc/apt/sources.list</em></span> 
</p><div class="example"><a name="id2450531"></a><p class="title"><b>Example 12. <span class="emphasis"><em>/etc/securetty</em></span> Configuration</b></p><pre class="screen">	<code class="prompt">#</code>echo "tty0" &gt;&gt; /etc/securetty 
	<code class="prompt">#</code>echo "ttys/0" &gt;&gt; /etc/securetty 
</pre></div><div class="example"><a name="id2450559"></a><p class="title"><b>Example 13. <span class="emphasis"><em>/mnt/tmp/dev</em></span></b></p><p>Debootstrap does not create device node for mounting the uml root file system, you can check this by: 
	</p> 
<pre> 
 $ cd /mnt/tmp/dev 
 $ ls ubd* 
</PRE>	 
	If this does not return <span class="emphasis"><em>ubd0</em></span> then, 
	 
<PRE> 
 $ sudo mknod --mode=660 ubd0 b 98 0 
 $ sudo chown root:disk ubd0 
</PRE>	 
<p><div class="example"><a name="id2450610"></a><p class="title"><b>Example 14. <span class="emphasis"><em>Edit /etc/inittab</em></span></b></p><p>This will allow you to login immediately after the boot messages</p><pre class="screen">	Comment out the following lines: 
	  2:23:respawn:/sbin/getty 38400 tty2  
	  3:23:respawn:/sbin/getty 38400 tty3 
	  4:23:respawn:/sbin/getty 38400 tty4 
	  5:23:respawn:/sbin/getty 38400 tty5 
	  6:23:respawn:/sbin/getty 38400 tty6 
	    
	Now modify tty1 to say tty0, the result should look like this: 
	  1:2345:respawn:/sbin/getty 38400 tty0 
	  #2:23:respawn:/sbin/getty 38400 tty2 
	  #3:23:respawn:/sbin/getty 38400 tty3 
	  #4:23:respawn:/sbin/getty 38400 tty4 
	  #5:23:respawn:/sbin/getty 38400 tty5 
	  #6:23:respawn:/sbin/getty 38400 tty6 
</PRE> 
<P><b>Ubuntu has no /etc/inittab file,</b> it is replaced by files in  
   <code>/etc/event.d</code> directory.  We don't need so many virtual consoles, 
   get rid three of them. 
<PRE> 
  $ sudo rm /mnt/tmp/etc/event.d/tty[4-6] 
</PRE> 
<div class="example"><a name="id2450642"></a> 
<p class="title"><b>Example 15. <span class="emphasis"><em>Enable The Synaptic Sources.list</em></span></b></p> 
<p> We also need to create apt source package data base for the first time by  
    running the second and third commands. 
 
<pre> 
$ sudo cp /etc/apt/sources.list /mnt/tmp/etc/apt/sources.list 
$ sudo chroot /mnt/tmp 
# apt-get update 
</pre> 
<p class="title"><b>Example 16. <span class="emphasis"><em>Add user to the uml  
system</em></span></b></p><p> 
Preparing user login accounts for the User Mode Linux system by: 
</p><pre> 
$ sudo chroot /mnt/tmp 
# adduser guest 
</pre> 
 Answer the prompted questions about the new user or press enter followed by a yes at  
the end. Type "exit" to end the chroot command. 
<a name="id2496478"></a> 
<a name="id2495478"></a><p class="title"> 
<b>Example 17. <span class="emphasis"><em>Run the kernel with UML</em></span></b></p><p> 
</p><pre> 
$ sudo umount /mnt/tmp 
$ linux.uml ubd0=uml-root-fs 
</pre><p> 
</p> 
<p> 
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="resources"></a>Other Resources</h2></div></div></div><p></p><div class="itemizedlist"><ul type="disc"><li><p><a href="http://user-mode-linux.sourceforge.net/" target="_top">User mode linux homepage</a></p></li><li><p><a href="http://user-mode-linux.sourceforge.net/UserModeLinux-HOWTO.html" target="_top">User mode linux howto</a></p></li><li><p><a href="http://gentoo-wiki.com/HOWTO_User_Mode_Linux" target="_top">User mode linux gentoo howto</a></p></li><li><p><a href="http://cosi.clarkson.edu/knowledge/workshops/sp05/installingxen/xen-tutorial.html" target="_top">Xen 2 Tutorial</a></p></li><li><p><a href="http://clarkson.edu/class/cs644/kernel/setup/uml/gdb_uml.html" target="_top">Debuging with User Mode Linux</a></p></li></ul></div></div></div> 
 
<h2>Running Network Services under User-Mode Linux Source</h2> 
<TABLE> 
  <TR><TD><a href="http://www.linuxjournal.com/article/9246">Part 1</a>&nbsp;&nbsp; 
      <TD><a href="http://www.linuxjournal.com/article/9296">Part 2</a>&nbsp;&nbsp; 
      <TD><a href="http://www.linuxjournal.com/article/9421">Part 3</a>&nbsp;&nbsp; 
</TABLE> 
 
   <h3>Running Network Services under User-Mode Linux, Part I</h3> 
   
        <h4>September 30th, 2006 by <a href="http://www.linuxjournal.com/user/800787" title="View user profile.">Mick Bauer</a><span class="taxonomy"></h4> 
      </div> 
   
<p> 
In my May 2006 Paranoid Penguin column, I expounded on the virtues of Debian 3.1's excellent 
support for virtualization environments, including User-Mode Linux.  In 
that same issue, in the article "User-Mode Linux", 
Matthew Hoskins gave a quick-and-dirty recipe for test-driving User-Mode 
Linux using prebuilt UML kernels and root filesystem images. 
</p><p> 
Did those articles whet your appetite for a more comprehensive and security-focused 
look at using UML? If so, you're in luck; for the next couple of columns, we're 
going to dive into the User-Mode Linux experience and cover every step 
(including every command) for creating your very 
own User-Mode Linux containers for network services. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb44dd8"></a> 
Objectives</div><p> 
So, why are we doing this, and what do we hope to achieve? As I've said 
before in this space, virtualization is similar to the concept of the 
chroot (changed root) jail.  It encapsulates a process or dmon into a 
subset of the operating environment in which it resides, in a manner that 
makes it much harder for attackers to get at the underlying environment 
should they succeed in compromising that process or dmon. 
</p><p> 
Whereas chrooting restricts a process to a subset of the host system's real 
filesystem, virtualization restricts the process to a complete virtual 
machine running within the host (real) machine.  This includes a completely 
virtualized hard disk, memory and kernel, and even virtualized system 
devices, such as network and sound cards.  In the case of User-Mode Linux, 
this is achieved by running a guest (virtual) kernel as a user-space 
process within the host (real) kernel. 
</p><p> 
Because both guest and host kernel are Linux kernels, virtualization 
in User-Mode Linux is fast and efficient.  And, because the guest kernel does 
<span class="emphasis"><em>not</em></span> need to run as root under the host kernel, even 
attackers who 
compromise some dmon on the guest system <span class="emphasis"><em>and</em></span> 
escalate their 
privileges to root (on the guest system) <span class="emphasis"><em>and</em></span> somehow manage to 
gain shell access to the underlying host system will have achieved 
only unprivileged access to that host system. 
</p><p> 
This does not make it impossible to gain root access to the host system. 
If attackers do make it as far as shell access on the host, they 
may be able to escalate their privileges via some local privilege 
escalation vulnerability in the host's kernel or some user-space 
program on the host.  (Remember: no vulnerability is strictly local 
on <span class="emphasis"><em>any</em></span> networked system!) It 
<span class="emphasis"><em>does</em></span> mean, however, that it's 
more difficult for attackers to get to the point of being able to exploit 
such a vulnerability, especially if it isn't also present on the guest 
(virtual) system. 
</p><p> 
This brings us to our design goals.  The guest machine should be 
as bare-bones as possible with respect to installed software--both 
to minimize resource utilization and to minimize its potential for 
compromise (its attack surface).  If, for example, the guest machine 
is to act as a DNS server, it should have basic network support, BIND 
(or some other DNS server package) and very little else.  No X Window 
System and no Apache--nothing else not directly related to DNS services. 
</p><p> 
If you're really paranoid, you even can skip the Secure Shell dmon 
and instead administer the system via a virtual serial console.  (Though 
allowing SSH from only authorized IP addresses, such as that of 
the host system, might be a more reasonable middle ground.) You could 
also run User-Mode Linux under SELinux; however, that's beyond the scope 
of this series of articles. 
</p><p> 
If a single bastion server is to host multiple network services--for 
example, Apache and BIND--you could run two different guest systems on 
the same host: one containing only Apache and its dependent packages 
and another containing only BIND et al.  In this way, a vulnerability in 
BIND would not lead directly to Web site defacement.  Conversely, a poorly 
coded Web application would not necessarily lead to DNS tampering. 
</p><p> 
In summary, our two design principles will be to run one virtual 
machine per major network service and to make each virtual machine 
as minimal and secure as possible.  The end result will (hopefully) be 
a very compartmentalized bastion server that places as much defensive 
abstraction as possible between attackers and total root compromise. 
</p><p> 
For the remainder of this series of articles, I use the example of 
a single guest system running BIND.  Both guest and host system are 
based on Debian 3.1, because Debian is so popular for UML guests (it 
lends itself to stripped-down installations--a trait it shares with 
Slackware).  However, most of what follows also applies to other Linux 
distributions on both host and guest. 
</p><p> 
Our tasks are: 
</p><div class="orderedlist"><ol type="1"><li><p> 
Build a host kernel optimized for hosting User-Mode Linux guests. 
</p></li><li><p> 
Build one or more guest kernels to run on top of the host. 
</p></li><li><p> 
Obtain and customize a prebuilt root filesystem for our guests. 
</p></li><li><p> 
Run, configure and harden our guest system for secure DNS services. 
</p></li></ol></div></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb456c8"></a> 
Preparing the Host</div><p> 
First, you need to make sure you've got the right kind 
of kernel on your host system.  You very likely may need 
to compile a new kernel. 
</p><p> 
On the one hand, some Linux distributions already have User-Mode Linux 
compiled into their default kernels.  On the other hand, your distribution 
of choice may or may not also have the skas (separate kernel address 
space) patch compiled in as well.  It is, in fact, somewhat unlikely that 
your default kernel has skas support.  Although the Linux kernel source 
code has included UML support since version 2.6.9, the skas patch is still 
maintained separately (and Linus has resisted its inclusion). 
</p><p> 
The skas patch is important.  It greatly improves UML performance 
and security by running the guest system's kernel in separate 
address space from its other processes (just like the host's 
kernel does).  The User-Mode Linux Web site's skas page on SourceForge 
provides a more detailed 
explanation of why you need skas (see the on-line Resources). 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45880"></a></div><div class="sidebar"><p class="title"><b> 
Keeping Your Kernels and Guests Straight</b></p><p> 
In the contexts of User-Mode Linux, VMware and other virtualization 
systems, we use the words host and guest in a very specific way.  Your 
host is the system that runs the virtualization environment--that 
is, it acts as a host to one or more virtual machines.  Guests 
are virtual machine instances that live on top of the host. 
</p><p> 
Therefore, when we speak of the host kernel and guest kernels, 
remember that guest kernels run on top of the host kernel.  In 
User-Mode Linux, your host kernel is a normal Linux kernel, compiled 
for your particular hardware platform (Intel x86, IBM PowerPC and so on), 
with User-Mode Linux features (including the optional skas patch) 
compiled in as well. 
</p><p> 
Your guest kernel, on the other hand, must be compiled to run on virtual 
hardware: the um architecture.  Other than that, it does 
<span class="emphasis"><em>not</em></span> 
need the skas patch or User-Mode Linux support enabled.  Unless, that is, 
you want to run other guest kernels on top of it.  Running guests 
within guests is possible (this is called nesting), but well beyond 
the scope of this article. 
</p><p> 
Each UML virtual machine instance consists of a guest kernel, a guest root 
filesystem and a COW (Copy On Write) file.  The root filesystem is a disk 
image file; it contains every file in your virtual machine except the 
kernel itself.  When you execute a guest kernel, the root filesystem file 
is mounted in precisely the same way you'd mount any other disk image, 
for example, a CD ISO file.  Like a CD-ROM, it's used in read-only mode. 
Any changes you make to the virtual filesystem in the course of a UML 
session, including new files and file deletions, are stored in a COW file. 
</p><p> 
Thanks to the magic of COWs, it's therefore possible to run the same 
guest kernel and root filesystem combination multiple times, by defining 
a unique COW file per instance. 
</p></div><p> 
To obtain kernel source code, your best bet may be simply to install your 
Linux distribution's kernel-source package.  Take care, however, that your 
distribution provides a kernel version of 2.6.9 or higher, because 
UML support is included from 2.6.9 onward, 
and prior UML patches had security vulnerabilities. 
</p><p> 
Because Debian 3.1 still uses kernel version 2.6.8, I decided not to use 
the official Debian kernel packages and instead downloaded the 2.6.17 
kernel from kernel.org.  I did, however, install the kernel-package 
package, which provides tools for generating Debian packages from official 
kernel source. 
</p><p> 
Besides kernel source code, you need the skas patch, the 
latest version of which is available on Blaisorblade's site (see Resources).  Be sure to download the 
patch version that corresponds to the kernel source code you're about 
to patch. 
</p><p> 
On my Debian host, I unpacked my official source code to 
/usr/src/linux-2.6.17.3, renamed the source code directory to 
/usr/src/linux-2.6.17.3-host and copied the skas patch tarball 
(skas-2.6.17-rc5-v9-pre9.patch.bz2) to /usr/src. I then changed 
ownership 
of the directory /usr/src/linux-2.6.17.3-host to a nonroot account. 
(Adhering to the principle of never being root unless you really need 
to, 
we're going to do most of this kernel build as an unprivileged user.) 
</p><p> 
Here are the commands I executed as root: 
 
</p><pre class="programlisting">host:/usr/src/# tar -xjvf ./linux-2.6.17.3.tar.bz 
host:/usr/src/# mv ./linux-2.6.17.3 ./linux-2.6.17.3-host 
host:/usr/src/# chown mick ./linux-2.6.17.3 
host:/usr/src/# su - mick 
</pre> 
<p> 
To apply the skas patch, I then navigated, as my nonroot user, to 
/usr/src/linux-2.6.17.3-host and ran the following command: 
 
</p><pre class="programlisting">host:/usr/src/linux-2.6.17.3-host$ bunzip2 -c 
 ../skas-2.6.17-rc5-v9 -pre9.patch.bz2 | patch -p1 
</pre> 
<p> 
Next, from the same directory, I issued the command <tt>make 
menuconfig</tt>.  When 
setting up the kernel configuration for User-Mode Linux, the defaults 
generally are fine, though you should ensure that the 
configuration matches your host's hardware.  In addition, it's probably 
prudent to double-check the following settings: 
</p><div class="itemizedlist"><ul type="disc"><li><p> 
Under Processor type and features, make sure /proc/mm is enabled. 
</p></li><li><p> 
Under Networking options, make sure IP: tunneling and 802.1d Ethernet 
Bridging are enabled.  If you intend to restrict guest system behavior 
with iptables, you also may want to check the Network packet filtering 
section to ensure that Core Netfilter Configuration, IP: Netfilter 
Configuration and Bridged IP/ARP packets filtering are set up. 
</p></li><li><p> 
Under Network device support, enable Universal TUN/TAP 
device driver support. 
</p></li><li><p> 
And, by all means, make sure to hard-compile (into the kernel, not as 
a module) the filesystem in which your system's root partition is formatted 
(for example, ext3 or ReiserFS). 
</p></li></ul></div><p> 
From this point on, the process is the same with any other kernel 
build: issue the commands <tt>make bzImage</tt> and 
<tt>make modules;</tt>.  Then, become 
root and issue the commands <tt>make modules</tt>, 
<tt>make modules_install</tt> and 
<tt>make install</tt>.  (Or in the case of Debian, use the 
<tt>make-kpkg</tt> command 
to achieve the same thing, and run <tt>dpkg</tt> to install the resulting kernel 
package.) 
</p><p> 
Once your new host kernel is installed, reboot your system.  Your host 
system is now capable of running User-Mode Linux guest systems. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3cf38"></a> 
Creating a Guest Kernel</div><p> 
Okay, we've got UML host capabilities, but we still need a guest kernel 
to run.  This process is somewhat simpler than the host-kernel build, 
because we don't need the skas patch. 
</p><p> 
First, navigate back to the directory in which your Linux kernel-source 
tarball resides, and unpack it a second time.  Remember when we renamed the 
unzipped source code directory? This was so we could unpack the kernel 
tarball a second time.  We need to build our host and guest kernels in 
separate source trees. 
</p><p> 
On my Debian test system, therefore, I unpacked the source 
tarball to /usr/src/linux-2.6.17.3, and this time, renamed it to 
/usr/src/linux-2.6.17.3-guest.  Again, change ownership of this directory 
to a nonprivileged user, and change your working directory to it. 
</p><p> 
Again, at this point we can skip the step of applying the skas 
patch.  Because we're going to compile our kernel for the special um 
(User-Mode Linux) architecture rather than for a real architecture like 
x86, I recommend you prepare your source code tree with the following 
three commands: 
 
</p><pre class="programlisting">host:/usr/src/linux-2.6.17.3-guest$ make mrproper ARCH=um 
host:/usr/src/linux-2.6.17.3-guest$ make defconfig ARCH=um 
host:/usr/src/linux-2.6.17.3-guest$ make menuconfig ARCH=um 
</pre> 
<p> 
The <tt>make mrproper</tt> command clears out any configuration and object 
files in your source tree; <tt>make defconfig</tt> generates a fresh default 
configuration file appropriate to the um architecture; and <tt>make 
menuconfig</tt>, 
of course, gives you the opportunity to fine-tune this configuration file. 
</p><p> 
Pay particular attention to the following: 
</p><div class="itemizedlist"><ul type="disc"><li><p> 
Life will be simpler if you skip loadable kernel module support 
and hard-compile everything into the kernel.  If you really want 
kernel modules, see the User-Mode Linux HOWTO, Section 2.2 (see 
Resources). 
</p></li><li><p> 
Under Processor type and features, double-check that your system 
architecture is set to um (User-Mode Linux), and make sure /proc/mm 
is enabled. 
</p></li><li><p> 
Under Networking options, make sure IP: tunneling and 802.1d Ethernet 
Bridging are enabled. 
</p></li><li><p> 
Under Network device support, enable Universal TUN/TAP device driver 
support. 
</p></li><li><p> 
Disable as many of the specialized hardware kernel modules as possible; this kernel 
is going to be running on virtualized hardware, so you won't need support 
for wireless LAN hardware, obscure parallel-port devices and so forth. 
</p></li></ul></div><p> 
Once you've saved your new configuration file, you can compile the 
kernel with this command (<span class="emphasis"><em>without</em></span> first becoming root; execute this as 
an unprivileged user): 
 
</p><pre class="programlisting">host:/usr/src/linux-2.6.17.3-guest$ make linux ARCH=um 
</pre> 
<p> 
Note that I did <span class="emphasis"><em>not</em></span> tell you to make a zipped or bzipped 
image.  Remember, you're going to be running this kernel as though it 
were a user-space command, so it shouldn't be compressed.  The finished 
kernel will be located in the top-level directory of your source tree 
(/usr/src/linux-2.6.17.3-guest in the above examples) and will be 
named linux--you'll probably want to rename it to something more 
descriptive, such as uml-guestkernel-2.6.17.3.  You'll also probably want 
to move it to the directory from which you intend to run it--perhaps 
something like /usr/local/uml/. 
</p><p> 
By the way, don't be scared by the size of your guest kernel file.  Most 
of that bulk is symbol information that will <span class="emphasis"><em>not</em></span> be loaded into 
memory when you execute it. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3d988"></a> 
Conclusion</div><p> 
Your host system now fully supports User-Mode Linux, and you've got a 
guest kernel image to run.  The next step is to obtain or create a root 
filesystem image to use with the guest kernel.  That's where we'll pick 
up again next time! 
</p> 
 
      <h3>Paranoid Penguin - Running Network Services under User-Mode Linux, Part II</h3> 
   
        <h4>December 1st, 2006 by <a href="http://www.linuxjournal.com/user/800787" title="View user profile.">Mick Bauer</a><span class="taxonomy"></h4> 
      </div> 
   
<p> 
Here in the Paranoid Penguin column, we're in the midst of building a 
virtual network server using User-Mode Linux.  Last month, I explained 
why this is a good idea, how it works, how to prepare your host for 
optimized User-Mode Linux operation and how to build a kernel for your 
guest (virtual) system(s). 
</p><p> 
This month, we turn our attention to the guest system: how to obtain a 
prebuilt root filesystem image, how to configure networking on both your 
host and guest systems, and how to begin customizing the root filesystem 
image for your own purposes. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb44dd8"></a> 
Quick Review</div><p> 
First, here's a quick review of what we're trying to do, in case you missed 
last month's column.  Our objective is to use User-Mode Linux to create 
one or more virtual guest machines, each running a different network 
service.  That way, if one application (for example, BIND) on one guest 
machine gets compromised somehow, Sendmail, Apache and whatever else 
you've got running on other guest systems (or on the underlying host 
system itself) won't be affected. 
</p><p> 
(Per User-Mode Linux convention, we're using the word host to denote 
a system on top of which virtual machines run and the word guest to denote 
a virtual system instance.) 
</p><p> 
Debian is our somewhat arbitrary choice here for both host and 
guest systems, due to the ease with which you can create bare-bones 
Debian installations, though User-Mode Linux itself is decidedly 
distribution-agnostic.  We'll create a single guest system, running 
BIND software for DNS services. 
</p><p> 
On the strength of last month's procedures, hopefully you've got a 
skas-enabled host kernel and a guest kernel compiled for the um 
architecture.  Now, it's time to acquire or build a root filesystem image. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb44fe8"></a> 
Just What Is a Root Filesystem Image, and How Will It Be Used?</div><p> 
When your Linux host starts up, it learns where / is via the 
root command-line switch; somewhere in lilo.conf or menu.lst is a 
kernel-invocation line containing something like 
<tt>root=/dev/hda1</tt>.  That's 
how it works with User-Mode Linux too, except that rather than a physical 
hard disk, such as /dev/hda, we generally use a virtual disk in the form of 
a single flat file, called a root filesystem image. 
</p><p> 
The root filesystem image contains a complete Linux distribution.  You've 
already created similar image files yourself if you've ever copied a 
CD-ROM to an ISO file (or vice versa).  Using a filesystem that takes the 
form of a single file has two important ramifications for User-Mode Linux: 
first, it helps keep your guest system relatively compact and portable; 
second, it makes change control as simple as tracking changes to a single 
file, via the COW file method. 
</p><p> 
Suppose I start a User-Mode Linux guest with this command: 
 
</p><pre class="programlisting">   umluser@host:~&gt; ./guestkernel ubd0=mycow,my_root_fs root=/dev/ubda 
</pre> 
<p> 
Note the umluser@host prompt.  I'm executing this command from a 
shell session to which I'm logged in as a regular user, 
<span class="emphasis"><em>not</em></span> 
root.  guestkernel is my executable User-Mode Linux guest kernel; 
ubd0 is a virtual disk device I'm declaring to consist of the image 
file my_root_fs plus a change-on-write (COW) file called mycow. 
The root switch defines our root partition to be the virtual disk ubda 
(identified by its full path, /dev/ubda). 
</p><p> 
Somewhat confusingly, by convention, virtual disk declarations 
use numbered device names (ubd0, ubd1 and so on), but root filesystem 
definitions use the corresponding letters instead (ubda, ubdb and so on), 
which are synonymous.  The command <tt>./guestkernel ubda=mycow,my_root_fs 
root=/dev/ubda</tt> actually works just as well on my SUSE system as the 
above command, but your distribution of choice may behave differently. 
</p><p> 
Strictly speaking, the COW file is optional.  If you specify one, 
changes you make to the image file during your User-Mode Linux session 
will be written to the COW file rather than to the disk image itself.  If 
you omit the COW filename, the image file will be written to 
directly by the guest kernel--that is, any changes you make to your 
guest system will be "permanent". 
</p><p> 
As far as I'm concerned, when using UML in security scenarios, COW files 
are mandatory.  A key assumption in using User-Mode Linux for hosting 
a network service is that this service may be compromised in some way, 
and if it is, you'll want to be able to recover as quickly as possible.  If 
you use a COW file, all you'll need to do to restore a guest system to its 
baseline state is delete the old COW file and create a new (empty) one. 
</p><p> 
Another key advantage of using COW files is that they allow you to use the 
same root filesystem image on more than one guest system 
simultaneously. 
All you need to do is specify a different COW file each time you bring 
up a guest kernel.  In fact, you can use both the same image file and 
the same kernel for multiple guests.  As you can guess, we're going to 
use a COW file in our example scenarios. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45510"></a> 
Getting a Root Filesystem Image</div><p> 
The procedure for building your own root filesystem image boils down 
to this: 
</p><div class="orderedlist"><ol type="1"><li><p> 
Create an empty filesystem image file and mount it to some directory. 
</p></li><li><p> 
Install Linux into that directory. 
</p></li></ol></div><p> 
Sounds simple, right? On Debian and SUSE it is--sort of.  On other 
distributions, it's much less so.  Regardless, I'm going to save a 
more-detailed discussion of that process for my next column, in which 
I'll cover what I consider to be advanced User-Mode Linux topics and 
techniques.  In the interests of getting you up and running with User-Mode 
Linux in a gratifyingly quick manner, for now I recommend you download 
a prebuilt image. 
</p><p> 
My favorite source of these is Nagafix Ltd.'s "UML 
Resources" page (see the on-line Resources) from whence you can download root filesystem 
images for not only Debian guests, but also Gentoo, Slackware, Fedora, 
Ubuntu and others.  Nagafix makes a reasonable effort to keep these 
images up to date with security patches, which is a nice touch. 
</p><p> 
In addition, Nagafix provides an MD5 and SHA hash of each image file 
it provides.  You may miss them if you click directly on the x86 and 
AMD64 links on the page cited above; instead, use the OS-name links, 
each of which leads to a page containing links not only to images but 
also to build logs and hashes, plus handy tips on how to update the 
images yourself. 
</p><p> 
I obtained my Debian 3.1 image by navigating to <a href="http://uml.nagafix.co.uk/">uml.nagafix.co.uk</a>, 
clicking on Debian 3.1, and then clicking on the root_fs and 
MD5 links to download the files Debian-3.1-x86-root_fs.bz2 and 
Debian-3.1-x86-root_fs.bz2.md5, respectively.  After my downloads were 
complete (the filesystem image itself is 169MB!), I verified the MD5 
signature from within a terminal window with the command: 
 
</p><pre class="programlisting">   md5sum -c ./Debian-3.1-x86-root_fs.bz2.md5 
</pre> 
</div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45a38"></a></div><div class="sidebar"><p class="title"><b> 
When in Doubt, Roll Your Own Image</b></p><p> 
Even if you use a root filesystem image from a trusted source and verify 
its integrity via an MD5, SHA or GPG hash/signature, the fact is, 
if you're truly worried about security (we are, aren't we?), you're much 
better off building your own filesystem image than using someone else's. 
</p><p> 
I'm indulging in just a little laziness and instant gratification by 
using a prebuilt image in this article, which I think is justifiable in 
the larger aim of encouraging UML experimentation and adoption.  Just 
be sure to check your image's hash/signature, and the first time you 
mount it in UML, run <tt>apt-get dist-upgrade</tt> (or YaST Online Update, yum 
or whatever update mechanism your guest's distro supports). 
</p><p> 
Next time, I'll discuss the filesystem image build process in more depth, 
as well as how to use iptables both on your host and on your guest OSes 
to add another layer of protection to your virtual machines. 
</p></div><p> 
And, now we're ready to boot our virtual guest for the first 
time.  We've got a guest kernel named uml-guestkernel-2.6.17.3 
(from my previous column's example) and a root filesystem image named 
Debian-3.1-x86-root_fs.bz2.  You should already be logged in to a terminal 
session as a nonroot user.  Uncompress the filesystem image with the 
command: 
 
</p><pre class="programlisting">   bunzip2 ./Debian-3.1-x86-root_fs.bz2 
</pre> 
<p> 
Next, just as a sanity 
check, try booting your guest system: 
 
</p><pre class="programlisting">   umluser@host:~&gt; ./uml-guestkernel-2.6.17.3 
   ubd0=testcow,Debian-3.1-x86-root_fs root=/dev/ubda 
</pre> 
<p> 
If all is well, you should see some User-Mode Linux messages, followed 
by a longer string of Linux kernel startup messages, ending with a login 
prompt.  Log in as root--you won't be prompted for a password.  Feel free 
to poke around a bit; you won't hurt anything that can't be fixed later 
by starting with a fresh COW file. 
</p><p> 
To see a list of installed packages, enter the command <tt>dpkg -l 
|less</tt>. 
You may be surprised by how few Debian packages are present.  Don't 
worry; you'll be able to install additional packets with apt-get, just 
like on a "real" Debian system.  When you're done with your initial 
exploration, issue the command <tt>halt</tt> to shut down your guest system 
cleanly.  We've got some things to do before your guest system can do 
any serious work--first and foremost is configuring networking. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb46010"></a> 
Using Bridged Networking with User-Mode Linux</div><p> 
There are a variety of ways to network UML guests, all of 
which are described in Rusty Russell's User-Mode Linux HOWTO (see 
Resources).  The 
best option for using UML guests as network servers is bridging, in 
which your host system acts like an Ethernet bridge between itself, 
the UML guests running on it and the outside world. 
</p><p> 
In a nutshell, the procedure is this: 
</p><div class="orderedlist"><ol type="1"><li><p> 
Configure your host's TCP/IP stack as a virtual bridge, and then define 
your "real" network interface as the first 
"port" on that bridge. 
</p></li><li><p> 
For each guest system you intend to run, create a local tunnel interface 
and define it as another port on the bridge. 
</p></li><li><p> 
When you start a guest system, define its virtual Ethernet interface 
(eth0) to be the tunnel interface you created in the previous step. 
</p></li></ol></div><p> 
Listing 1 shows the precise series of commands this translates to, adapted 
from David Cannings' useful article "Networking UML Using 
Bridging".  All 
these commands must be executed as root. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb46538"></a></div><div class="sidebar"><p class="title"><b> 
Listing 1. Setting Up Bridged Networking</b></p><pre class="programlisting">   root@host# bash -c 'echo 1 &gt; /proc/sys/net/ipv4/ip_forward' 
   root@host# apt-get install bridge-utils uml-utilities 
   root@host# ifconfig eth0 0.0.0.0 promisc up 
   root@host# brctl addbr uml-bridge 
   root@host# brctl setfd uml-bridge 0 
   root@host# brctl sethello uml-bridge 0 
   root@host# brctl stp uml-bridge off 
   root@host# ifconfig uml-bridge 192.168.250.250 netmask 255.255.255.0 up 
   root@host# brctl addif uml-bridge eth0 
   root@host# tunctl -u umluser -t uml-conn0 
   root@host# chgrp uml-net /dev/net/tun 
   root@host# chmod 660 /dev/net/tun 
   root@host# ifconfig uml-conn0 0.0.0.0 promisc up 
   root@host# brctl addif uml-bridge uml-conn0 
</pre></div><p> 
The first command enables IP forwarding on your host.  Although, 
technically, 
bridging happens at a lower level than IP forwarding, they amount to 
the same thing from the kernel's perspective.  Accordingly, if you have 
a local iptables policy on your host, you'll need to add rules to the 
FORWARD table to enable traffic to and from the tunnel interfaces you 
attach to the host's bridge. 
</p><p> 
The second command (apt-get install...), obviously, installs the Debian 
packages bridge-utils and uml-utilities.  bridge-utilities provides 
the brctl command, and uml-utilities provides the tunctl command.  For 
these commands to work, your host kernel needs to have been compiled with 
802.1d Ethernet bridging, IP tunneling, Bridged IP/ARP packet filtering 
and Universal TUN/TAP device driver support. 
</p><p> 
The third command in Listing 1 (ifconfig eth0...) may seem a bit 
scary.  It resets your host's Ethernet interface to a (temporarily) 
IP-free state.  Be prepared for an interruption in local network 
functionality after you execute this command. 
</p><p> 
The subsequent six commands, however, will restore it by defining a new 
virtual bridge device (called uml-bridge), configuring it, assigning 
your host's IP address to it (192.168.250.250 in this example), and 
attaching eth0 to it as a virtual bridge port.  If the IP address of eth0 
on your host was 10.1.1.10 before you reset it to 0.0.0.0, after 
issuing the first four brctl commands you would use <tt>ifconfig uml-bridge 
10.1.1.10 netmask 255.255.255.0 up</tt>.  At this point, your host should be 
able to interact with the outside world in exactly the same way as it 
did before (unless of course your local iptables policy doesn't have 
appropriate FORWARD rules yet). 
</p><p> 
All right, our host system is now a bridge.  All that remains is to attach 
a tunnel port to it.  You should repeat the remaining steps in Listing 1 
(starting with tunctl -u...) for each guest system you intend to run. 
</p><p> 
In the tunctl -u... command, 
umluser is the name of the unprivileged 
account you intend to use when executing guest kernels, and uml-conn0 
is the name of the new tunnel interface you're creating. 
</p><p> 
In the subsequent chgrp and chmod commands, we're changing the 
permissions of the virtual tunnel device, always /dev/net/tun, to be 
readable and writable by our unprivileged account.  In this example, 
therefore, the account umluser belongs to the group uml-net.  (On my 
real-life test system, I instead used the the group wheel, which my 
unprivileged account mick belongs to.) 
</p><p> 
After setting the new tunnel interface's IP address to 0.0.0.0 (just like 
we did with eth0), we define it as another port on the local bridge with 
that last brctl command. 
</p><p> 
That's it! Now when we start the guest system, we add the option 
<tt>eth0=tuntap,uml-conn0</tt> to our kernel command line, which tells the 
kernel to use the tunnel interface uml-conn0 as its virtual eth0.  Our 
complete example command line, which unlike Listing 1, should be run by 
a nonprivileged user rather than root, looks like this: 
 
</p><pre class="programlisting">   umluser@host$ ./debkern ubd0=debcow,debroot root=/dev/ubda 
   eth0=tuntap,uml-conn0 
</pre> 
<p> 
After the virtual machine starts, you can assign an IP address 
to (virtual) eth0 via <tt>ifconfig</tt>, define a default route via <tt>route 
add...</tt> (using the same gateway IP that your host system uses), set DNS 
lookup information in /etc/resolv.conf, and, in short, configure it in 
precisely the same way that you'd configure a real Debian system. 
</p><p> 
Once your virtual machine is successfully communicating with your local 
LAN and beyond, you should immediately configure apt-get and use it to 
install the latest Debian patches on your virtual guest.  You'll need 
apt-get working anyhow to install the network software you've just gone 
to all the trouble of building this virtual machine to run.  In the case 
of our example virtual DNS server, these would probably be the Debian 
packages bind9 and maybe also bind9-doc.  Remember, all of these 
changes will be made to your COW file, so be sure to specify the same 
COW file on subsequent startups (or merge it into your image via the 
uml_moo command). 
</p><p> 
Next time, we'll wrap up this series by discussing additional security 
controls you can use on your guest systems, a nifty COW file trick or two 
and, of course, how to create a custom root filesystem image.  Until then, 
be safe! 
</p> 
 
      <h3>Paranoid Penguin - Running Network Services under User-Mode Linux, Part III</h3> 
   
        <h4>January 1st, 2007 by <a href="http://www.linuxjournal.com/user/800787" title="View user profile.">Mick Bauer</a><span class="taxonomy"></h4> 
  <div class="content"> 
        Fine-tune and firewall your UML guest systems.     
<p> 
In the last two Paranoid Penguin columns, I walked you through the process of 
building a virtual network server using User-Mode Linux.  We built both 
host and guest kernels, obtained a prebuilt root filesystem image, 
configured networking on the host, and when we left off last month, 
we finally had booted our guest kernel with bridged networking, ready for 
configuration, patching and server software installation. 
</p><p> 
This month, I tie up some loose ends in our example guest 
system's startup and configuration, show you the uml_moo command, 
demonstrate how to write firewall rules on your UML host system, offer 
some miscellaneous security tips and give some pointers on creating your 
own root filesystem image.  And, can you believe we will have scratched 
only the surface of User-Mode Linux, even after three articles? 
Hopefully, 
we'll have scratched deeply enough for you to be off to a good start! 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb44dd8"></a> 
Guest System Configuration</div><p> 
You may recall that last time we set up bridged networking on our host, 
creating a local tunnel interface called uml-conn0 that we bridged 
to the host system's "real" eth0 interface.  If you don't have last 
month's column, my procedure was based on the one by David Cannings (see 
the on-line Resources).  When we then started up our host 
(User-Mode) kernel, we mapped a virtual eth0 on the guest to uml-conn0 
via a kernel parameter, like so:</p><pre class="programlisting">umluser@host$ ./debkern ubd0=debcow,debroot 
 root=/dev/ubda eth0=tuntap,uml-conn0</pre><p> 
The last parameter, obviously, contains the networking magic: 
eth0=tuntap,uml-conn0.  It can be translated to "the guest kernel's eth0 
interface is the host system's tunnel/tap interface uml-conn0".  This is 
important to understand; to the host (real) system, the guest's Ethernet 
interface is called uml-conn0, but to the guest system itself, its 
Ethernet interface is plain-old eth0. 
</p><p> 
Therefore, if you run an iptables (firewall) rule set on either host 
or guest (I strongly recommend you do so at least on the host), any 
rules that use interface names as sources or targets must take this 
difference in nomenclature into account.  We'll discuss some example 
host firewall rules shortly, but we're not quite done with guest-kernel 
startup parameters yet. 
</p><p> 
Going back to that startup line, we've got definitions of our virtual 
hard drive (ubd0, synonymous with ubda), our path to virtual root 
and, of course, our virtual Ethernet interface.  But what about memory? 
</p><p> 
On my OpenSUSE 10.1 host system, running a UML Debian guest with the 
above startup line resulted in a default memory size of about 
29MB--pretty puny by modern standards, especially if I want that guest 
system 
to run real-world, Internet-facing network services. Furthermore, I've 
got an entire gigabyte of physical RAM on my host system to allocate; 
I easily can spare 256MB of RAM for my guest system. 
</p><p> 
To do so, all I have to do is pass the parameter mem=256M to the guest 
kernel, like so:</p><pre class="programlisting">umluser@host$ ./debkern mem=256M ubd0=debcow,debroot 
 root=/dev/ubda eth0=tuntap,uml-conn0</pre><p> 
Obviously enough, you can specify however much more or less than that as 
you like, and you can allocate different amounts of RAM for multiple guests 
running on a single host (perhaps 128M for your virtual DNS server, 
but 512M for your virtual Web server, for example).  Just be sure to leave 
enough non-guest-allocated RAM for your host system to do what 
<span class="emphasis"><em>it</em></span> 
needs to do. 
</p><p> 
Speaking of which, you'll save a lot of RAM on your host system by not 
running the X Window System, which I've always recommended against running 
on hardened servers anyhow.  The X server on my test host uses around 
100MB, with actual desktop managers requiring more.  On top of this, the X 
Window System has a history of security vulnerabilities with varying degrees 
of exploitability by remote attackers (remember, a "local" vulnerability 
ceases being local the moment any non-local user starts a shell). 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45358"></a> 
Managing COW Files</div><p> 
If, as I recommended last month, you run your UML guest with a Copy on 
Write (COW) file, you may be wondering whether your UML guest-kernel 
startup line is the only place you can manage COW files.  (A COW file 
is created automatically when you specify a filename for one in your 
ubd0=... parameter.) 
</p><p> 
Actually, the uml-utilities package includes two standalone commands 
for managing COW files: uml_moo and uml_mkcow.  Of the two, uml_moo is 
the most likely to be useful to you.  You can use uml_moo to merge all 
the filesystem changes contained in a COW file into its parent root 
filesystem image. 
</p><p> 
For example, if I run the example UML guest kernel startup command 
described earlier, and from within that UML guest session I configure 
networking, apply all the latest security patches, install BIND v9 and 
configure it and finally achieve a "production-ready" state, I may 
decide that it's time to take a snapshot of the UML guest by merging 
all those changes (written, so far, only into the file debcow) into 
the actual filesystem image (debroot).  To do so, I'd use this command:</p><pre class="programlisting">umluser@host$ uml_moo ./debcow newdebroot</pre><p> 
The first argument 
you specify to uml_moo is the COW file you want to merge.  Because a COW 
file contains the name of the filesystem image to which it corresponds, you 
don't have to specify this.  Normally, however, you should specify the 
name of the new filesystem image you want to create. 
</p><p> 
My example uml_moo command, therefore, will leave the old root filesystem 
image debroot intact (maybe it's also being used by other UML guests, 
or maybe I simply want to preserve a clean image), creating a new 
filesystem named newdebroot that contains my fully configured and 
updated root filesystem. 
</p><p> 
If I want to do a hard merge, however, which replaces the old filesystem 
image with the merged one (with the same filename as before), perhaps 
because my hard disk is too full for extra image files, I'd instead use 
<tt>uml_moo -d ./debcow</tt> (the -d stands for destructive merge). 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45778"></a> 
iptables and UML</div><p> 
Whether you chroot your User-Mode guests, and whether you use 
SELinux, depends on how deep you want your layers of security 
to go and how much time and effort you're able to expend.  However, I 
strongly recommend that on any Internet-facing, bridged User-Mode Linux 
system, you use iptables on your UML host to restrict your guest systems' 
network behavior. 
</p><p> 
On the one hand, if your UML system already resides outside a firewall 
in a DMZ network (as should any Internet server), you're already 
protecting your internal network from the possibility of a network 
server compromise.  However, there's really no good reason not to take the 
opportunity also to use UML-host iptables rules to reduce the ability of 
an attacker to use one compromised UML guest to attack other UML guests, 
the UML host itself or other systems in your DMZ network. 
</p><p> 
There are two categories of rules I strongly recommend you 
consider.  First, anti-IP-spoofing rules can help ensure that every 
packet sent by each guest bears the source IP address you actually 
assigned to that guest, and not a forged (spoofed) source IP.  These are 
low-maintenance rules that you'll have to think about only at setup time, 
unless for some reason you change a guest system's IP address. 
</p><p> 
Suppose you have a UML system whose IP address is 10.1.1.10 and whose 
tun/tap interface is (from the host's perspective) uml-conn0.  The 
anti-spoofing rules you install on the UML host might therefore look 
like that shown in Listing 1. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb45988"></a></div><div class="sidebar"><p class="title"><b> 
Listing 1. Anti-IP-Spoofing Rules</b></p><pre class="programlisting">iptables -A FORWARD -m physdev --physdev-in uml-conn0 
 -s ! 10.1.1.10 -j LOG --log-prefix "Spoof from uml-conn0" 
 
iptables -A FORWARD -m physdev --physdev-in uml-conn0 
 -s ! 10.1.1.10 -j DROP</pre></div><p> 
The first rule logs the spoofed packets; the second one actually drops 
them.  As you may know, the LOG target doesn't cause packets to cease 
being evaluated against subsequent iptables rules, but the DROP target 
does, so the LOG rule must come before the DROP rule. 
</p><p> 
Due to space constraints, I can't launch into a primer on how to write 
iptables rules or how they're managed on your Linux distribution of 
choice.  But, I can talk about the bridge-specific magic in Listing 1: 
the physdev iptables module and the --physdev-in parameter. 
</p><p> 
Usually, we use iptables' -i and -o flags to denote which network 
interface packets are received and sent from, respectively.  However, 
when writing iptables rules on a system doing bridged networking, we 
need to be a bit more precise, especially when we're also using tun/tap 
interfaces, as eth0 then takes on a different role than in normal 
Layer 3 (routed) networking. 
</p><p> 
Therefore, where we might normally use <tt>-i 
uml-conn0</tt> in a rule, 
on a bridging host, we should instead use <tt>-m physdev --physdev-in 
uml-conn0</tt>.  Similarly, instead of <tt>-o 
uml-conn0</tt>, we'd use <tt>-m physdev 
--physdev-out uml-conn0</tt>.  As with other module invocations, you 
need only one instance of <tt>-m physdev</tt> if a given 
iptables rule uses both the 
--physdev-in and --physdev-out rules. 
</p><p> 
After setting up a pair of anti-IP-spoofing rules, you also should create 
a set of "service-specific" rules that actually govern how your guest 
system may interact with the rest of the world, including other guest 
systems and the host itself. 
</p><p> 
Remember that in our example scenario the guest system is a DNS 
server.  Therefore, I'm going to enforce this logical firewall policy: 
</p><div class="orderedlist"><ol type="1"><li><p> 
The UML guest may accept DNS queries (both TCP and UDP). 
</p></li><li><p> 
The UML guest may recurse DNS queries against upstream (external) 
servers. 
</p></li><li><p> 
The UML guest may send its log messages to a log server (called 
logserver). 
</p></li><li><p> 
The UML host may initiate SSH sessions on the UML guest. 
</p></li></ol></div><p> 
Listing 2 shows iptables commands that could enforce this policy. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb462d0"></a></div><div class="sidebar"><p class="title"><b> 
Listing 2. Service Rules for the UML Guest</b></p><pre class="programlisting">iptablee -A FORWARD -m state --state 
 RELATED,ESTABLISHED -j ACCEPT 
 
iptables -A FORWARD -m physdev --physdev-out uml-conn0 
 -p udp --dport 53 -m state --state NEW -j ACCEPT 
 
iptables -A FORWARD -m physdev --physdev-out uml-conn0 
 -p tcp --dport 53 -m state --state NEW -j ACCEPT 
 
iptables -A FORWARD -m physdev --physdev-in uml-conn0 
 -p udp --dport 53 -d ! 10.1.1.0/24 -m state --state NEW -j ACCEPT 
 
iptables -A FORWARD -m physdev --physdev-in uml-conn0 
 -p tcp --dport 53 -d ! 10.1.1.0/24 -m state --state NEW -j ACCEPT 
 
iptables -A FORWARD -m physdev --physdev-in uml-conn0 
 -p udp --dport 514 -d logserver -m state --state NEW -j ACCEPT 
 
iptables -A FORWARD -j LOG --log-prefix 
 "Forward Dropped by default" 
 
iptables -A FORWARD -j DROP 
 
iptables -A OUTPUT -d 10.1.1.10 -p tcp --dport 22 -m 
 state --state NEW -j ACCEPT</pre></div><p> 
Listing 2 has two parts: a complete set of FORWARD rules and a single 
OUTPUT rule.  Because, logically speaking, UML guest systems are 
"external" 
to the UML host's kernel, interactions between UML guests and each other, 
and also interactions between UML guests and the rest of the world, 
are handled via FORWARD rules.  Interactions between UML guests and the 
underlying host system, however, are handled by INPUT and OUTPUT rules 
(just like any other interactions between external systems and the 
host system). 
</p><p> 
Because all of my logical rules except #4 are enforced by iptables FORWARD 
rules, Listing 2 shows my UML host's complete FORWARD table, including an 
initial rule allowing packets associated with already-approved sessions, 
and a final pair of "default log &amp; drop" rules.  Note my use of the physdev 
module; I like to use interface-specific rather than IP-specific rules 
wherever possible, as that tends to make it harder for attackers to 
play games with IP headers. 
</p><p> 
The last rule in Listing 2 should, in actual practice, appear somewhere 
in the middle of a similar block of OUTPUT rules (beginning with an 
allow-established rule and ending with a default log/drop rule pair), 
but I wanted to illustrate that where the source or destination of a 
rule involves the UML host system, you can write an ordinary OUTPUT or 
INPUT rule (respectively) rather than a FORWARD rule. 
</p><p> 
Because your UML host is acting as an Ethernet bridge, you can write 
still-more-granular and low-level firewall rules--even filtering by 
MAC addresses, the ARP protocol and so forth.  But for that level of 
filtering, you'll need to install the ebtables command.  iptables rules 
of the type I've just described should, however, suffice for most 
bastion-host situations. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3cfe8"></a> 
Miscellaneous Security Notes</div><p> 
If you patched your UML host's kernel with the SKAS patch, you've already 
got reasonably good assurance that an attacker who compromises a UML 
guest won't be able to do much, if anything, on the host system.  However, 
I'm not one to argue against paranoia, so I also recommend you chroot 
your UML guest system.  This is described in detail on the UML Wiki (see 
Resources).  And, what about shell access 
to your UML guests? There are various ways to access "local 
consoles".  You 
get one automatically when you start your UML guest from a UML 
host shell manually--after your UML kernel loads, you'll be presented with a 
login prompt. 
</p><p> 
That doesn't do you much good if you start your UML guest automatically 
from a script, however.  The "Device Inputs" page on the User-Mode Linux 
home page (see Resources) describes 
how to map UML guest virtual serial lines to UML host consoles.  For me, 
however, it's easiest simply to install SSH on my UML guest system, 
configure and start its SSH dmon, and create a firewall rule that 
allows connections to it only from my UML host. 
</p><p> 
Generally speaking, you want to use the same security controls and tools 
on your UML guest (tripwire, chrooted applications, SELinux, tcpwrappers 
and so on) as you would on any other bastion server. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3d250"></a> 
Building Your Own Root Filesystem Image</div><p> 
Describing in detail the process of building your own root filesystem 
image from scratch would require its own article (one which I may yet 
write).  Suffice it to say, the process is all but identical to that 
of creating your own bootable Linux CD or DVD, without the final step 
of burning your image file to some portable medium.  There are three 
major steps: 
</p><div class="orderedlist"><ol type="1"><li><p> 
Create an empty filesystem image file with <tt>dd</tt>. 
</p></li><li><p> 
Format the image file. 
</p></li><li><p> 
Mount it to a directory via loopback. 
</p></li><li><p> 
Install Linux into it. 
</p></li></ol></div><p> 
The first three steps are the easiest.  To create a 1GB ext3 image file, 
I'd run the commands shown in Listing 3 as root. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3d720"></a></div><div class="sidebar"><p class="title"><b> 
Listing 3. Making and Mounting an Empty Filesystem Image</b></p><pre class="programlisting">dd if=/dev/zero of=./mydebroot bs=1024K count=1000 
mkfs.ext4 ./mydebroot 
mkdir /mnt/debian 
mount -o loop ./mydebroot /mnt/debian</pre></div><p> 
Installing Linux into this directory gets a bit more involved, but if 
you've got a SUSE host system, the Software module in YaST includes a 
wizard called "Installation into Directory".  Like other YaST modules, 
this is an easy-to-use GUI. 
</p><p> 
Similarly, if you run Debian, you can use the command 
<tt>debootstrap</tt>.  See 
Michael McCabe and Demetrios Dimatos' handy article "Installing User 
Mode Linux" for detailed instructions on using debootstrap to populate 
your root filesystem image. 
</p><p> 
See the UML Wiki for some pointers to similar utilities in other 
distributions.  The Linux Bootdisk HOWTO (see Resources), 
although not 
specific to UML, is also useful. 
</p></div><div class="simplesect" lang="en"><div class="titlepage"><a name="N0xa50890.0xb3dae8"></a> 
Conclusion</div><p> 
I hope you're well on your way to building your own 
virtual network servers using User-Mode Linux! The two most 
important sources of UML information are the UML home page 
and the UML Wiki (see Resources).  Those and the other Web sites 
mentioned in this piece should help you go much further with User-Mode 
Linux than I can take you in an introductory series of articles like 
this.  Have fun, and be safe! 
</p><p><span class="bold"><b>Resources for this article:</b></span> <a href="http://www.linuxjournal.com/article/9457">/article/9457</a>. 
</p></div></div> 
<div class="authorblurb"><p> 
Mick Bauer (<a href="mailto:darth.elmo@wiremonkeys.org">darth.elmo@wiremonkeys.org</a>) is Network 
Security 
Architect for one of the US's largest banks.  He is the author of 
the O'Reilly book <span class="emphasis"><em>Linux Server Security</em></span>, 2nd edition 
(formerly called 
<span class="emphasis"><em>Building Secure Servers With Linux</em></span>), an occasional 
presenter at 
information security conferences and composer of the "Network 
Engineering Polka". 
</p></div> 
 
<h2><a href="http://man.sourcentral.org/ubuntu710/1+linux.uml"><b>ubuntu710</b></a></h2> 
 
<hr noshade="noshade" size="1"> 
<div id="ubuntu"> 
<h1 align="center">LINUX</h1><a name="heading1"></a> 
 
<h2>NAME</h2> 
 
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
  <tbody><tr align="left" valign="top"> 
    <td width="10%"> 
 
    <td width="89%"> 
      <p>linux -- User-mode Linux</p> 
     
   
</tbody></table><a name="heading2"></a> 
 
<h2>SYNOPSIS</h2> 
 
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
  <tbody><tr align="left" valign="top"> 
    <td width="10%"> 
 
    <td width="89%"> 
      <p><b>linux</b> [<i>options</i> ...]</p> 
     
   
</tbody></table><a name="heading3"></a> 
 
<h2>DESCRIPTION</h2> 
 
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
  <tbody><tr align="left" valign="top"> 
    <td width="10%"> 
 
    <td width="89%"> 
      <p>This manual page briefly documents User-mode Linux.</p> 
 
      <p>This manual page was written for the <b>Debian GNU/Linux</b> distribution because the original program does not have a manual page. Check <b>linux --help</b> for an up-to-date synopsis.</p> 
     
   
</tbody></table><a name="heading4"></a> 
 
<h2>OPTIONS</h2> 
 
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
  <tbody><tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>mem=<i>memory</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
      <p>This 
controls how much "physical" memory the kernel allocates for the 
system. The size is specified as a number followed by one of 'k', 'K', 
'm', 'M', which have the obvious meanings. This is not related to the 
amount of memory in the physical machine. It can be more, and the 
excess, if it's ever used, will just be swapped out.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>iomem=<i>name</i>,<i>file</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Configure <i>file</i> as a named IO memory region named <i>name</i>.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>gdb-pid=<i>pid</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>gdb-pid 
is used to attach an external debugger to UML. This may be an 
already-running gdb or a debugger-like process like strace.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>debugtrace</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Causes 
the tracing thread to pause until it is attached by a debugger and 
continued. This is mostly for debugging crashes early during boot, and 
should be pretty much obsoleted by the debug switch.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>honeypot</p> 
     
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>This 
makes UML put process stacks in the same location as they are on the 
host, allowing exploits such as stack smashes to work against UML.</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>debug</p> 
     
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
      <p>Starts 
up the kernel under the control of gdb. See the kernel debugging 
tutorial and the debugging session pages in the user-mode-linux-doc 
package for more information.</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>root=<i>file</i></p> 
     
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
      <p>This 
is actually used by the generic kernel in exactly the same way as in 
any other kernel. If you configure a number of block devices and want 
to boot off something other than ubd0, you would use something like 
"root=/dev/ubd5". Another notation is the use of the major and the 
minor number of the device, i.e. root=98:0, for ubd0.</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
 
    <td> 
      <p>To use hostfs for the root filesystem, use the syntax "root=/dev/root rootflags=/ rootfstype=hostfs"</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>umid=<i>name</i></p> 
     
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
      <p>This 
is used to assign a unique identity to this UML machine This is used 
for naming the pid file and management console socket. I.e. to access 
to the management console for an already running image (i.e. 
umid=test), just launch uml_mconsole test from the host command line.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>uml_dir=<i>directory</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>The location to place the pid and umid files.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>initrd=<i>file</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>This is used to boot UML from an initrd image. The argument is the name of the file containing the image.</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td width="5%"> 
      <p>jail</p> 
     
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Enables the protection of kernel memory from processes</p> 
     
   
<tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>con[0-9]*=<i>description</i></p> 
     
   
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Attach a console to a host channel. Examples of channels include ttys, ptys, pts terminals, xterms, and file descriptors.</p> 
     
 
<tr><td><td><td> 
   <OL><LI><b>tty</b> 
      <p>This 
will make UML attach the device to the specified tty. If the tty that 
you specify is the slave end of a tty/pty pair, something else must 
have already opened the corresponding pty in order for this to work.</p> 
       <pre><b>con1=tty:/dev/tty3</b></pre> 
      <LI><b>pty</b> 
      <p>This 
will cause UML to allocate a free host pty for the device. The pty will 
be announced in the boot log. You would attach to it via the 
corresponding tty.</p> 
      <pre><b>con1=pty</b></pre> 
      <LI><b>pts terminal</b> 
      <p>This is similar to pty above, but the specified UML device will be attached 
to a free pts device on the host. Look at the boot log to see which one.</p> 
 
 
      <pre><b>con1=pts</b></pre> 
 
      <LI><b>xterm</b> 
      <p>UML will run an xterm and the device will be attached to it.</p> 
      <pre><b>con1=xterm</b></pre> 
      <LI><b>file descriptors</b> 
      <p>If 
you set up a file descriptor on the UML command line, you can attach a 
UML device to it. This is most commonly used to put the main console 
back on stdin and stdout after assigning all the other consoles to 
something else.</p> 
 
      <pre><b>con0=fd:0,fd:1 con=xterm</b></pre> 
</OL> 
     
   
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>You can also specify different input and output channels for a device by  
        putting a comma between them:</p> 
     
      <pre><b>ssl3=tty:/dev/tty2,xterm</b></pre> 
     
<tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>See <i>Setting up Serial Lines and Consoles (link to URL file:///usr/share/doc/user-mode-linux-doc/html/input.html)</i> for a more information.</p> 
     
      <p>ssl[0-9]*=<i>description</i></p> 
     
   
  <tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Attach a serial line to a host channel. The same options are supported as for consoles, described above.</p> 
     
   
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>fake_ide</p> 
     
 
  <tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Create ide0 entries that map onto ubd devices.</p> 
     
   
<tr><td><td><td> 
   <OL><LI><b>ubd[0-7][r][s]=file</b> 
       <LI><b>ubd0r=/tmp/debian-woody.ext2</b> 
       <LI><b>ubd0rs=/tmp/debian-woody.ext2</b> 
       <LI><b>ubd0=/tmp/chroot</b> 
   </OL>     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
 
    <td> 
      <p>This 
is used to associate a device with a file or in the underlying 
filesystem. Usually, there is a filesystem in the file, but that's not 
required. Swap devices containing swap files can be specified like 
this. Also, a file which doesn't contain a filesystem can have its 
contents read in the virtual machine by running dd on the device. 
Appending an 'r' will cause that device to be mounted read-only. 
Appending an 's' tells UML to open the file using O_SYNC (synchronous 
I/O).</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
    <td> 
 
 
    <td> 
      <p>The ubd option can no longer be used to specify a hostfs root filesystem. See the "root" option for a more correct method.</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>udb</p> 
 
  <tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
      <p>This 
option is here solely to catch ubd -&gt; udb typos, which can be to 
impossible to catch visually unless you specifically look for them. The 
only result of any option starting with 'udb' is an error in the boot 
output.</p> 
     
   
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>fakehd</p> 
     
 
  <tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Change the ubd device name to "hd", allowing programs within UML to access UBD devices as if they were normal IDE disks.</p> 
     
   
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>eth[0-9]+=<i>transport</i>,<br> 
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>options</i></p> 
     
   
      <tr align="left" valign="top"> 
    <td> 
    <td> 
 
    <td> 
      <p>Configure a network device. Formats and examples follow (one for each configured transport).</p> 
     
   
  <tr align="left" valign="top"> 
    <td width="100%"> 
 
    <td width="0%"> 
 
    <td> 
      <p>eth[0-9]+=ethertap,<i>device</i>,<i>ethernet_address</i>,<i>tap_ip_address</i></p> 
     
   
      <p><b>eth0=ethertap,tap0,,192.168.0.1</b></p> 
 
      <p>eth[0-9]+=tuntap,,<i>ethernet_address</i>,<i>ip_address</i></p> 
           
      <p><b>eth0=tuntap,,fe:fd:0:0:0:1,192.168.0.1</b></p> 
           
      <p>eth[0-9]+=daemon,<i>ethernet_address</i>,<i>type</i>,<i>control_socket</i>,<i>data_socket</i></p> 
           
      <p><b>eth0=daemon,,unix,/var/run/uml-utilities/uml_switch.ctl</b></p> 
 
      <p>eth[0-9]+=slip,<i>slip_ip</i></p> 
                 
      <p><b>eth0=slip,192.168.0.1</b></p> 
                 
      <p>eth[0-9]+=mcast,<i>ethernet_address</i>,<i>address</i>,<i>port</i>,<i>ttl</i></p> 
      <p><b>eth0=mcast,,224.2.3.4:5555,3</b></p> 
                 
               
 
  <tr align="left" valign="top"> 
    <td> 
 
    <td> 
      <p>mode=tt</p> 
                 
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
                  <p>When 
both CONFIG_MODE_TT and CONFIG_MODE_SKAS are enabled, this option 
forces UML to run in tt (tracing thread) mode. It is not the default 
because it's slower and less secure than skas mode.</p> 
 
<tr align="left" valign="top"> 
     <td> 
 
     <td> 
        <p>mode=skas0</p> 
                 
<tr align="left" valign="top"> 
    <td> 
    <td> 
    <td> 
                  <p>Disables 
SKAS3 usage, so that SKAS0 is used, unless you specify mode=tt. Note 
that this was recently added - on older kernels you must use simply 
"skas0".</p> 
                 
<tr> 
                <td> 
 
                <td> 
                  <p>skas0</p> 
                 
 
 
 
<tr align="left" valign="top"> 
    <td> 
    <td> 
                <td> 
                  <p>Disables SKAS3 usage, so that SKAS0 is used, unless you specify mode=tt.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>mconsole=notify:<i>socket</i></p> 
                 
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Requests 
that the mconsole driver send a message to the named Unix socket 
containing the name of the mconsole socket. This also serves to notify 
outside processes when UML has booted far enough to respond to mconsole 
requests.</p> 
                 
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>aio=2.4</p> 
                 
 
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>This 
is used to force UML to use 2.4-style AIO even when 2.6 AIO is 
available. 2.4 AIO is a single thread that handles one request at a 
time, synchronously. 2.6 AIO is a thread which uses the 2.6 AIO 
interface to handle an arbitrary number of pending requests. 2.6 AIO is 
not available in tt mode, on 2.4 hosts, or when UML is built with 
/usr/include/linux/aio_abi.h not available. Many distributions don't 
include aio_abi.h, so you will need to copy it from a kernel tree to 
your /usr/include/linux in order to build an AIO-capable UML.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>hostfs=<i>rootdir</i>,<i>flags</i></p> 
                 
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>This 
is used to set hostfs parameters. The root directory argument is used 
to confine all hostfs mounts to within the specified directory tree on 
the host. If this isn't specified, then a user inside UML can mount 
anything on the host that's accessible to the user that's running it. 
The only flag currently supported is 'append', which specifies that all 
files opened by hostfs will be opened in append mode.</p> 
                 
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>xterm=<i>terminal <br>&nbsp;&nbsp;&nbsp;emulator</i>, 
                  <i>title <br>&nbsp;&nbsp;&nbsp;switch</i>, <i>exec switch</i></p> 
                 
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Specifies 
an alternate terminal emulator to use for the debugger, consoles, and 
serial lines when they are attached to the xterm channel. The values 
are the terminal emulator binary, the switch it uses to set its title, 
and the switch it uses to execute a subprocess, respectively. The title 
switch must have the form exec switch must have the form 
'&lt;switch&gt; command arg1 arg2 The default values are 
'xterm=xterm,-T,-e'. Values for gnome-terminal are 
'xterm=gnome-terminal,-t,-x'.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>noptraceldt</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Turns 
off usage of PTRACE_LDT, even if host supports it. To support 
PTRACE_LDT, the host needs to be patched using the current skas3 patch.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>noptracefaultinfo</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Turns 
off usage of PTRACE_FAULTINFO, even if host supports it. To support 
PTRACE_FAULTINFO, the host needs to be patched using the current skas3 
patch.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>noprocmm</p> 
                 
 
<tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Turns 
off usage of /proc/mm, even if host supports it. To support /proc/mm, 
the host needs to be patched using the current skas3 patch.</p> 
                 
               
 
  <tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>nosysemu</p> 
                 
 
  <tr align="left" valign="top"> 
                <td> 
                <td> 
 
 
                <td> 
                  <p>Turns 
off syscall emulation patch for ptrace (SYSEMU) on. SYSEMU is a 
performance-patch introduced by Laurent Vivier. It changes behaviour of 
ptrace() and helps reducing host context switch rate. To make it 
working, you need a kernel patch for your host, too. See 
http://perso.wanadoo.fr/laurent.vivier/UML/ for further information.</p> 
                 
               
 
              <tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>--help</p> 
                 
 
              <tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Prints syntax information.</p> 
                 
               
 
              <tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>--version</p> 
                 
 
              <tr align="left" valign="top"> 
                <td> 
                <td> 
 
                <td> 
                  <p>Prints the version number of the kernel.</p> 
                 
               
<tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>--showconfig</p> 
                 
<tr align="left" valign="top"> 
               <td> 
                <td> 
 
                <td> 
                  <p>Prints 
the configuration used to build the kernel. To print all the options 
used to build the "linux" uml kernel and save them in "config_file" you 
can use</p> 
 
                  <p><b>linux --showconfig &gt; config_file</b></p> 
                 
               
            </tbody></table> 
 
            <h2>SEE ALSO</h2> 
 
            <table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
              <tbody><tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>The <i>UserModeLinux-HOWTO (link to URL file:///usr/share/doc/user-mode-linux-doc/html/UserModeLinux-HOWTO.html)</i></p> 
                 
               
            </tbody></table><a name="heading6"></a> 
 
            <h2>AUTHOR</h2> 
 
            <table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%"> 
              <tbody><tr align="left" valign="top"> 
                <td> 
 
                <td> 
                  <p>User-mode Linux was written by Jeff Dike and others.</p> 
 
                  <p>This manual page was written by Matt Zimmerman mdz@debian.org for the <b>Debian GNU/Linux</b> system, based on <b>linux --help</b> and the user-mode-linux website.</p> 
                 
               
            </tbody></table> 
           
         
      </tbody></table> 
     
   
</tbody></table> 
 
</div> 
 
  
<p class="footer">           
by Oliver Paukstadt in 2003, 2004, 2005, 2006, 2007, 2008  
<br>Last Change: 2007-09-15, 16:02 
</p> 
 
<h2><a href="http://my.opera.com/subjam/blog/current-uml-configuration"  
    target="newwindow">UML Network Configuration</a></h2> 
<h2><a href="http://user-mode-linux.sourceforge.net/network.html"  
    target="newwindow">Simple UML Networking</a></h2> 
<h2><a href="http://user-mode-linux.sourceforge.net/old/networking.html"  
    target="newwindow">Setting up the UML network</a></h2> 
<h2><a href="http://user-mode-linux.sourceforge.net/old/mconsole.html"  
    target="newwindow">The Management Console</a></h2> 
<h2><a href="http://www.iakovlev.org/index.html?p=1151&m=1&l1=5"  
    target="newwindow">UML: The Origin</a></h2> 
<h2><a href="http://www.michaeldolan.com/1030"  
    target="newwindow">Using Linux KVM Virtualization on Ubuntu Gutsy</a></h2> 
<h2><a href="https://help.ubuntu.com/community/KVM"  
    target="newwindow">The Kernel Virtual Machine</a></h2> 
 
<a name="DebSqz"></a><h3>UML Root File System For Debian/Squeeze</h3> 
 
<PRE> 
 $ sudo mkdir /src3/UML; sudo chown hsu:hsu /src3/UML; cd /src3/UML; cwd=`pwd` 
 # Nowadays, we don't run user-mode-linux from Ubuntu or Debian.  We compile
 # it ourselves.
 # $ sudo dpkg -r user-mode-linux # We don't run Ubuntu user-mode-linux 
 #                                Get the Debian one we cached in Amath-Server 
 # $ scp $HOME/Desktop/user-mode-linux_2.6.32-1um-3_amd64.deb $HOME/Desktop 
 # $ cd $HOME/Desktop; sudo dpkg -i user-mode-linux_2.6.32-1um-3_amd64.deb 
 # $ cd $cwd    # Probably, you need to install uml-utilities from Ubuntu. 
 $ scp -r as:/backup/UML-tool/* .  
 $ dd if=/dev/zero of=./DebWzy-UltraLight.ext4 bs=1024K count=1000 
 $ mkfs.ext4 DebWzy-UltraLight.ext4 
 $ sudo mount -o loop DebWzy-UltraLight.ext4 /mnt/tmp 
 $ sudo debootstrap --arch amd64 squeeze /mnt/tmp http://amdm/debian 
 $ sudo chroot /mnt/tmp  
 # cd /dev  
 # for i in 0 1 2 3 4 5 6 7; do mknod ubd$i b 98 $[ $i * 16 ]; done 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 ;; In another xterm, run "update-base" to update basic setup, such as:  
 ;; $ sudo update-base
 ;; $ sudo rm /mnt/tmp/tmp/DebianNet-pkgs.txt 
 ;; $ sudo cp DebianNetFiles/DebianNet-UltraLight.txt  /mnt/tmp/tmp 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 # su root  ;; Must set root passwd! Otherwise, can not "su root" to  
            ;; turn off uml 
 # adduser hsu 
 # adduser guest 
 # adduser guest1 
 # adduser guest2 
 # adduser guest3 
 # adduser guest4 
 # adduser guest5 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 ;; $ cat /etc/apt/sources.list
 ;; deb http://140.120.7.21/debian squeeze main contrib
 ;; deb http://140.120.7.21/debian sid main contrib
 ;; deb http://security.debian.org/ squeeze/updates main contrib
 ;; # deb-src http://ftp.tw.debian.org/debian/ squeeze main
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 # apt-get -f install 
 # for pkg in `grep "\binstall$" /tmp/DebianNet-UltraLight.txt | awk '{print $1} '`; do apt-get -y --force-yes install $pkg; done 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;   Nothing is installed, since the database for binary package was 
 ;; not updated yet! As usual: aptitude update; aptitude safe-upgrade
 ;; aptitude clean; And then we do the last two steps one more time.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 # apt-get autoremove 
 # apt-get dselect-upgrade  
 # aptitude clean
 # deborphan
 # ls /var/cache/apt/archives/*deb 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 ;; In another xterm 
 ;; $ df /mnt/tmp 
 ;; Filesystem           1K-blocks      Used Available Use% Mounted on 
 ;; /dev/loop1              806288    379416    385912  50% /mnt/tmp 
 ;; sudo emacs /mnt/tmp/etc/ssh/ssh_config
 ;; sudo emacs /mnt/tmp/etc/ssh/sshd_config
 ;;  $ ls -l /mnt/tmp/etc/ssh/*~
 ;; -rw-r--r-- 1 root root 1669 Apr  4 23:35 /mnt/tmp/etc/ssh/ssh_config~
 ;; -rw-r--r-- 1 root root 2489 Jun  2 14:00 /mnt/tmp/etc/ssh/sshd_config~
 ;;  $ sudo mv /mnt/tmp/etc/ssh/ssh_config~ /mnt/tmp/etc/ssh/ssh_config.orig
 ;;  $ sudo mv /mnt/tmp/etc/ssh/sshd_config~ /mnt/tmp/etc/ssh/sshd_config.orig
 ;;  $ diff /mnt/tmp/etc/ssh/ssh_config /mnt/tmp/etc/ssh/ssh_config.orig
 ;; 22c22
 ;; < ForwardX11Trusted yes
 ;; ---
 ;; > #   ForwardX11Trusted yes
 ;; 39c39
 ;; < Port 22
 ;; ---
 ;; > #   Port 22
 ;;  $ diff /mnt/tmp/etc/ssh/sshd_config /mnt/tmp/etc/ssh/sshd_config.orig
 ;; 27c27
 ;; < PermitRootLogin no
 ;; ---
 ;; > PermitRootLogin yes
 ;; # Need the kernel modules, etc, created while compiling UML. 
 ;; # Each time, user-mode-linux package updated, update the /lib/modules 
 ;; # directory of the correspondent uml root filesystem. 
 ;; $ cd /usr/local/lib/uml/lib/modules
 ;; $ sudo cp -r * /mnt/tmp/lib/modules 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
 # cd /etc/init.d 
 # ./ssh stop 
 # update-rc.d -f hwclock.sh remove 
 # update-rc.d -f hwclockfirst.sh remove 
 # ls -l /var/run/rsyslogd.pid
 # more /var/run/rsyslogd.pid
 # kill -2  $(cat /var/run/rsyslogd.pid)
 # mount
 /dev/ubd0 on / type ext3 (rw)
 /var/run on /run type none (rw,bind)
 /var/lock on /run/lock type none (rw,bind)
 /dev/shm on /run/shm type none (rw,bind)
 # umount /run/shm /run/lock /run /
 # mount
 /dev/ubd0 on / type ext3 (rw)
 # exit 
 $ sudo umount /mnt/tmp 
 $ ls -l /mnt/tmp          # Still exists, do it one more time 
 $ sudo umount /mnt/tmp 
 $ sudo fuser -m /mnt/tmp  # Else, find who is using it 
 
 /mnt/tmp:            16368rce 
 
 $ sudo kill -2 16368  
</PRE> 
 
<a name="UMLResizing"></a><h3>Resize UML Root Filesystem, (Not tested  
yet!)</h3> 
 
<P> <b>Note: (03/23/2013)</b>  Based on steps listed here, the shell script 
<a href="./ResizeRootFS"><b>ResizeRootFS</b></a> was written to automate rfs 
resizing. 

<PRE> 
 # ext2resize is obsoleted, install new package. 
 $ sudo apt-get install e2fsprogs 
 $ which resize2fs 
 $ scp as:/src2/uml-rfs/DebWzy-UltraLight.ext4.gz DebWzy.ext4.gz 
 $ cp DebWzy.ext4.gz DebWzy-Light.ext4.gz 
 # Do the following twice, once for DebWzy.ext4, another one for DebWzy-Light.ext4. 
 $ gunzip DebWzy.ext4.gz 
 $ du -m  DebWzy.ext4 
 801 DebWzy.ext4 
 # Padding zeros to the end of DebWzy.ext4 to grow it to 5GB. 
 # 2.2GB per minute. 
 $ dd if=/dev/zero of=DebWzy.ext4 bs=1M seek=801 count=4200 
 $ resize2fs DebWzy.ext4 
 # It asks you to run e2fsck on DebWzy.ext4, do it! 
 $ resize2fs DebWzy.ext4 
 $ sudo mount -o loop DebWzy.ext4 /mnt/tmp 
 $ sudo cp DebianNetFiles/DebianNet-pkgs.txt  /mnt/tmp/tmp 
 $ sudo chroot /mnt/tmp 
 # apt-get -f install 
 # for pkg in `grep "\binstall$" /tmp/DebianNet-pkgs.txt | awk '{print $1} '`; do apt-get -y --force-yes install $pkg; done 
 # apt-get autoremove  %% Some packages may automatically installed, after installation 
 #                     %% they become useless. 
 # apt-get dselect-upgrade  
 # apt-get clean 
 # ls /var/cache/apt/archives/*deb 
 # Do the same for DebWzy-Light.ext4 with count=2200. 
 #
 # At final stage, compress both DebWzy-Light.ext4 and DebWzy.ext4 and scp them 
 # to as:/src2/uml-rfs to back them up.  We we need new uml root filesystem, we
 # can scp it from as.
</PRE> 
 
</body></html> 
